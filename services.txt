Code combined from: C:\Users\p01mansoorg\Documents\python\Studio-S_manager\backend\src\services
================================================================================



================================================================================
FILE: ./backend/src/services\appointment.service.ts
================================================================================

import { pool } from '../config/database.js';
import AppError from '../utils/appError.js';
import { logger } from '../utils/logger.js';

interface AppointmentFilters {
  client_id?: string;
  staff_id?: string;
  service_id?: string; // Changed from treatment_id
  status?: string;
  date_from?: string;
  date_to?: string;
  page?: number;
  limit?: number;
}

interface CreateAppointmentData {
  client_id: string;
  staff_id: string;
  service_id: string; // Changed from treatment_id
  booking_date: string; // Changed from appointment_date
  start_time: string;
  end_time: string;
  duration_minutes: number;
  notes?: string;
  created_by?: string;
}

export class AppointmentService {
  /**
   * Find all appointments with filters
   * FIXED: Use 'bookings' table and 'services' table
   */
  async findAll(filters: AppointmentFilters) {
    const {
      client_id,
      staff_id,
      service_id,
      status,
      date_from,
      date_to,
      page = 1,
      limit = 50,
    } = filters;

    const params: any[] = [];
    let paramIndex = 1;
    const conditions: string[] = [];

    if (client_id) {
      conditions.push(`b.client_id = $${paramIndex++}`);
      params.push(client_id);
    }

    if (staff_id) {
      conditions.push(`b.staff_id = $${paramIndex++}`);
      params.push(staff_id);
    }

    if (service_id) {
      conditions.push(`b.service_id = $${paramIndex++}`);
      params.push(service_id);
    }

    if (status) {
      conditions.push(`b.status = $${paramIndex++}`);
      params.push(status);
    }

    if (date_from) {
      conditions.push(`b.booking_date >= $${paramIndex++}`);
      params.push(date_from);
    }

    if (date_to) {
      conditions.push(`b.booking_date <= $${paramIndex++}`);
      params.push(date_to);
    }

    const whereClause =
      conditions.length > 0 ? `WHERE ${conditions.join(" AND ")}` : "";

    const offset = (page - 1) * limit;
    params.push(limit, offset);

    const query = `
      SELECT 
        b.*,
        c.first_name || ' ' || c.last_name as client_name,
        c.phone as client_phone,
        c.email as client_email,
        s.name as treatment_name,
        s.duration_minutes as treatment_duration,
        s.price as treatment_price
      FROM bookings b
      LEFT JOIN clients c ON b.client_id = c.id
      LEFT JOIN services s ON b.service_id = s.id
      ${whereClause}
      ORDER BY b.booking_date DESC, b.start_time DESC
      LIMIT $${paramIndex} OFFSET $${paramIndex + 1}
    `;

    const countQuery = `
      SELECT COUNT(*) 
      FROM bookings b
      ${whereClause}
    `;

    const [dataResult, countResult] = await Promise.all([
      pool.query(query, params),
      pool.query(countQuery, params.slice(0, -2)),
    ]);

    return {
      appointments: dataResult.rows,
      total: parseInt(countResult.rows[0].count),
      page,
      limit,
      totalPages: Math.ceil(parseInt(countResult.rows[0].count) / limit),
    };
  }

  /**
   * Find appointment by ID
   * FIXED: Use 'bookings' and 'services' tables
   */
  async findById(id: string) {
    const result = await pool.query(
      `
      SELECT 
        b.*,
        c.first_name || ' ' || c.last_name as client_name,
        c.phone as client_phone,
        c.email as client_email,
        s.name as treatment_name,
        s.description as treatment_description,
        s.duration_minutes as treatment_duration,
        s.price as treatment_price
      FROM bookings b
      LEFT JOIN clients c ON b.client_id = c.id
      LEFT JOIN services s ON b.service_id = s.id
      WHERE b.id = $1
    `,
      [id]
    );

    if (result.rows.length === 0) {
      throw AppError.notFound("Appointment not found");
    }

    return result.rows[0];
  }

  /**
   * Create new appointment
   * FIXED: Use 'bookings' table
   */
  async create(data: CreateAppointmentData) {
    // Check for conflicts
    const conflictCheck = await pool.query(
      `
      SELECT id FROM bookings
      WHERE staff_id = $1
        AND booking_date = $2
        AND status NOT IN ('cancelled')
        AND no_show = false
        AND (
          (start_time <= $3 AND end_time > $3)
          OR (start_time < $4 AND end_time >= $4)
          OR (start_time >= $3 AND end_time <= $4)
        )
    `,
      [data.staff_id, data.booking_date, data.start_time, data.end_time]
    );

    if (conflictCheck.rows.length > 0) {
      throw AppError.conflict(
        "This time slot is already booked for the selected staff member"
      );
    }

    const result = await pool.query(
      `
      INSERT INTO bookings (
        client_id, staff_id, service_id, 
        booking_date, start_time, end_time, 
        total_price, status, notes
      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
      RETURNING *
    `,
      [
        data.client_id,
        data.staff_id,
        data.service_id,
        data.booking_date,
        data.start_time,
        data.end_time,
        0, // total_price - you might want to fetch this from services table
        "scheduled",
        data.notes || null,
      ]
    );

    logger.info(`Appointment created: ${result.rows[0].id}`);
    return result.rows[0];
  }

  /**
   * Update appointment
   * FIXED: Use 'bookings' table
   */
  async update(id: string, data: Partial<CreateAppointmentData>) {
    const fields: string[] = [];
    const values: any[] = [];
    let paramIndex = 1;

    const allowedFields = [
      "client_id",
      "staff_id",
      "service_id",
      "booking_date",
      "start_time",
      "end_time",
      "notes",
      "status",
    ];

    for (const [key, value] of Object.entries(data)) {
      if (allowedFields.includes(key) && value !== undefined) {
        fields.push(`${key} = $${paramIndex++}`);
        values.push(value);
      }
    }

    if (fields.length === 0) {
      throw AppError.badRequest("No valid fields to update");
    }

    values.push(id);

    const result = await pool.query(
      `
      UPDATE bookings
      SET ${fields.join(", ")}, updated_at = CURRENT_TIMESTAMP
      WHERE id = $${paramIndex}
      RETURNING *
    `,
      values
    );

    if (result.rows.length === 0) {
      throw AppError.notFound("Appointment not found");
    }

    logger.info(`Appointment updated: ${id}`);
    return result.rows[0];
  }

  /**
   * Cancel appointment
   * FIXED: Use 'bookings' table
   */
  async cancel(id: string, reason?: string, cancelled_by?: string) {
    const result = await pool.query(
      `
      UPDATE bookings
      SET status = 'cancelled',
          cancellation_reason = $1,
          cancelled_at = CURRENT_TIMESTAMP,
          updated_at = CURRENT_TIMESTAMP
      WHERE id = $2
      RETURNING *
    `,
      [reason || null, id]
    );

    if (result.rows.length === 0) {
      throw AppError.notFound("Appointment not found");
    }

    logger.info(`Appointment cancelled: ${id}`);
    return result.rows[0];
  }

  /**
   * Check-in appointment
   * FIXED: Use 'bookings' table
   */
  async checkIn(id: string) {
    const result = await pool.query(
      `
      UPDATE bookings
      SET status = 'checked_in',
          checked_in_at = CURRENT_TIMESTAMP,
          updated_at = CURRENT_TIMESTAMP
      WHERE id = $1 AND status = 'scheduled'
      RETURNING *
    `,
      [id]
    );

    if (result.rows.length === 0) {
      throw AppError.badRequest(
        "Appointment not found or cannot be checked in"
      );
    }

    logger.info(`Appointment checked in: ${id}`);
    return result.rows[0];
  }

  /**
   * Complete appointment
   * FIXED: Use 'bookings' table
   */
  async complete(id: string, notes?: string) {
    const result = await pool.query(
      `
      UPDATE bookings
      SET status = 'completed',
          notes = COALESCE($1, notes),
          completed_at = CURRENT_TIMESTAMP,
          updated_at = CURRENT_TIMESTAMP
      WHERE id = $2 AND status IN ('scheduled', 'checked_in')
      RETURNING *
    `,
      [notes || null, id]
    );

    if (result.rows.length === 0) {
      throw AppError.badRequest("Appointment not found or cannot be completed");
    }

    logger.info(`Appointment completed: ${id}`);
    return result.rows[0];
  }

  /**
   * Get availability slots for a staff member
   * FIXED: Use 'bookings' table
   */
  async getAvailability(
    staff_id: string,
    date: string,
    duration_minutes: number
  ) {
    // Get staff working hours (simplified - you may want to store this in DB)
    const workingHours = {
      start: "09:00",
      end: "18:00",
    };

    // Get existing appointments
    const existingAppointments = await pool.query(
      `
      SELECT start_time, end_time
      FROM bookings
      WHERE staff_id = $1
        AND booking_date = $2
        AND status NOT IN ('cancelled')
        AND no_show = false
      ORDER BY start_time
    `,
      [staff_id, date]
    );

    // Generate available slots
    const availableSlots: string[] = [];
    const slotInterval = 30; // 30-minute intervals

    // Calculate number of slots in working hours
    const startMinutes = this.timeToMinutes(workingHours.start);
    const endMinutes = this.timeToMinutes(workingHours.end);

    for (
      let time = startMinutes;
      time <= endMinutes - duration_minutes;
      time += slotInterval
    ) {
      const slotTime = this.minutesToTime(time);
      const slotEndTime = this.minutesToTime(time + duration_minutes);

      // Check if slot conflicts with existing appointments
      const hasConflict = existingAppointments.rows.some((apt) => {
        const aptStart = this.timeToMinutes(apt.start_time);
        const aptEnd = this.timeToMinutes(apt.end_time);
        const slotStart = time;
        const slotEnd = time + duration_minutes;

        return (
          (slotStart >= aptStart && slotStart < aptEnd) ||
          (slotEnd > aptStart && slotEnd <= aptEnd) ||
          (slotStart <= aptStart && slotEnd >= aptEnd)
        );
      });

      if (!hasConflict && time + duration_minutes <= endMinutes) {
        availableSlots.push(slotTime);
      }
    }

    return availableSlots;
  }

  /**
   * Get calendar view of appointments
   * FIXED: Use 'bookings' and 'services' tables
   */
  async getCalendar(start_date: string, end_date: string, staff_id?: string) {
    const params: any[] = [start_date, end_date];
    let paramIndex = 3;
    let staffCondition = "";

    if (staff_id) {
      staffCondition = `AND b.staff_id = $${paramIndex}`;
      params.push(staff_id);
    }

    const result = await pool.query(
      `
      SELECT 
        b.id,
        b.booking_date as appointment_date,
        b.start_time,
        b.end_time,
        b.status,
        c.first_name || ' ' || c.last_name as client_name,
        s.name as treatment_name,
        s.price as treatment_price
      FROM bookings b
      LEFT JOIN clients c ON b.client_id = c.id
      LEFT JOIN services s ON b.service_id = s.id
      WHERE b.booking_date >= $1
        AND b.booking_date <= $2
        ${staffCondition}
      ORDER BY b.booking_date, b.start_time
    `,
      params
    );

    return result.rows;
  }

  /**
   * Helper to convert time string to minutes
   */
  private timeToMinutes(time: string): number {
    const [hours, minutes] = time.split(":").map(Number);
    return hours * 60 + minutes;
  }

  /**
   * Helper to convert minutes to time string
   */
  private minutesToTime(minutes: number): string {
    const hours = Math.floor(minutes / 60);
    const mins = minutes % 60;
    return `${String(hours).padStart(2, "0")}:${String(mins).padStart(2, "0")}`;
  }
}

export const appointmentService = new AppointmentService();


================================================================================
FILE: ./backend/src/services\client.service.ts
================================================================================

import { pool } from '../config/database.js';
import AppError from '../utils/appError.js';
import { logger } from '../utils/logger.js';

interface CreateClientData {
  name: string;
  email?: string;
  phone: string;
  whatsapp?: string;
  notes?: string;
  date_of_birth?: string;
  address?: string;
}

export class ClientService {
  /**
   * Create new client
   */
  async create(data: CreateClientData) {
    // Split name into first and last name
    const nameParts = data.name.trim().split(/\s+/);
    const firstName = nameParts[0];
    const lastName = nameParts.slice(1).join(" ") || ".";

    // Check if client with same phone exists - FIXED: use is_active
    const existingClient = await pool.query(
      "SELECT id FROM clients WHERE phone = $1 AND is_active = true",
      [data.phone]
    );

    if (existingClient.rows.length > 0) {
      throw AppError.conflict("Client with this phone number already exists");
    }

    const result = await pool.query(
      `INSERT INTO clients (
        first_name, 
        last_name, 
        email, 
        phone, 
        whatsapp,
        notes,
        date_of_birth,
        address,
        is_active,
        created_at,
        updated_at
      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, true, NOW(), NOW()) 
      RETURNING *`,
      [
        firstName,
        lastName,
        data.email || null,
        data.phone,
        data.whatsapp || data.phone,
        data.notes || null,
        data.date_of_birth || null,
        data.address || null,
      ]
    );

    logger.info(`Client created: ${result.rows[0].id}`);
    return this.formatClient(result.rows[0]);
  }

  /**
   * Find all clients with pagination
   * FIXED: Use 'bookings' table instead of 'appointments'
   * FIXED: Use 'is_active' instead of 'active'
   */
  async findAll(filters: { search?: string; page?: number; limit?: number }) {
    const { search, page = 1, limit = 50 } = filters;
    const offset = (page - 1) * limit;

    let query = `
      SELECT 
        c.*,
        COUNT(DISTINCT b.id) as total_appointments,
        COUNT(DISTINCT b.id) FILTER (WHERE b.status = 'completed') as completed_appointments,
        COUNT(DISTINCT s.id) as total_purchases,
        SUM(s.final_amount) as lifetime_value,
        MAX(b.booking_date) as last_appointment_date,
        MAX(s.sale_date) as last_purchase_date
      FROM clients c
      LEFT JOIN bookings b ON c.id = b.client_id
      LEFT JOIN sales s ON c.id = s.client_id
      WHERE c.is_active = true
    `;

    const params: any[] = [];
    let paramIndex = 1;

    if (search) {
      query += ` AND (
        c.first_name ILIKE $${paramIndex} OR 
        c.last_name ILIKE $${paramIndex} OR 
        c.phone ILIKE $${paramIndex} OR
        c.email ILIKE $${paramIndex}
      )`;
      params.push(`%${search}%`);
      paramIndex++;
    }

    query += `
      GROUP BY c.id
      ORDER BY c.created_at DESC
      LIMIT $${paramIndex} OFFSET $${paramIndex + 1}
    `;

    params.push(limit, offset);

    // Count query - FIXED: use is_active
    let countQuery = `SELECT COUNT(*) FROM clients WHERE is_active = true`;
    const countParams: any[] = [];

    if (search) {
      countQuery += ` AND (
        first_name ILIKE $1 OR 
        last_name ILIKE $1 OR 
        phone ILIKE $1 OR 
        email ILIKE $1
      )`;
      countParams.push(`%${search}%`);
    }

    const [dataResult, countResult] = await Promise.all([
      pool.query(query, params),
      pool.query(countQuery, countParams),
    ]);

    return {
      clients: dataResult.rows.map(this.formatClient.bind(this)),
      total: parseInt(countResult.rows[0].count),
      page,
      limit,
      totalPages: Math.ceil(parseInt(countResult.rows[0].count) / limit),
    };
  }

  /**
   * Search clients (for quick search/autocomplete)
   * FIXED: use is_active
   */
  async search(searchTerm: string) {
    const searchPattern = `%${searchTerm}%`;

    const result = await pool.query(
      `SELECT 
        id,
        first_name,
        last_name,
        email,
        phone,
        whatsapp
      FROM clients 
      WHERE is_active = true
        AND (
          first_name ILIKE $1 OR 
          last_name ILIKE $1 OR 
          phone ILIKE $1 OR
          email ILIKE $1
        )
      ORDER BY last_name, first_name
      LIMIT 10`,
      [searchPattern]
    );

    return result.rows.map((client: any) => ({
      id: client.id,
      name: `${client.first_name} ${client.last_name}`,
      email: client.email,
      phone: client.phone,
      whatsapp: client.whatsapp,
    }));
  }

  /**
   * Find client by ID with detailed info
   * FIXED: Use 'bookings' instead of 'appointments'
   */
  async findById(id: string) {
    const result = await pool.query(
      `SELECT 
        c.*,
        COUNT(DISTINCT b.id) as total_appointments,
        COUNT(DISTINCT b.id) FILTER (WHERE b.status = 'completed') as completed_appointments,
        COUNT(DISTINCT b.id) FILTER (WHERE b.status = 'cancelled') as cancelled_appointments,
        COUNT(DISTINCT b.id) FILTER (WHERE b.no_show = true) as no_shows,
        COUNT(DISTINCT s.id) as total_purchases,
        SUM(s.final_amount) as lifetime_value,
        MAX(b.booking_date) as last_appointment_date,
        MAX(s.sale_date) as last_purchase_date
      FROM clients c
      LEFT JOIN bookings b ON c.id = b.client_id
      LEFT JOIN sales s ON c.id = s.client_id
      WHERE c.id = $1
      GROUP BY c.id`,
      [id]
    );

    if (result.rows.length === 0) {
      throw AppError.notFound("Client not found");
    }

    return this.formatClient(result.rows[0]);
  }

  /**
   * Update client
   */
  async update(id: string, data: Partial<CreateClientData>) {
    const fields: string[] = [];
    const values: any[] = [];
    let paramIndex = 1;

    // Handle name field
    if (data.name) {
      const nameParts = data.name.trim().split(/\s+/);
      fields.push(`first_name = $${paramIndex++}`);
      values.push(nameParts[0]);
      fields.push(`last_name = $${paramIndex++}`);
      values.push(nameParts.slice(1).join(" ") || ".");
    }

    // Handle other fields
    const fieldMap: Record<string, string> = {
      email: "email",
      phone: "phone",
      whatsapp: "whatsapp",
      notes: "notes",
      date_of_birth: "date_of_birth",
      address: "address",
    };

    for (const [key, dbField] of Object.entries(fieldMap)) {
      if (data[key as keyof CreateClientData] !== undefined) {
        fields.push(`${dbField} = $${paramIndex++}`);
        values.push(data[key as keyof CreateClientData]);
      }
    }

    if (fields.length === 0) {
      throw AppError.badRequest("No fields to update");
    }

    values.push(id);

    const result = await pool.query(
      `UPDATE clients 
       SET ${fields.join(", ")}, updated_at = NOW()
       WHERE id = $${paramIndex}
       RETURNING *`,
      values
    );

    if (result.rows.length === 0) {
      throw AppError.notFound("Client not found");
    }

    logger.info(`Client updated: ${id}`);
    return this.formatClient(result.rows[0]);
  }

  /**
   * Get client history (appointments and purchases)
   * FIXED: Use 'bookings' table and 'services' table
   */
  async getHistory(id: string) {
    // Verify client exists
    const clientCheck = await pool.query(
      "SELECT id FROM clients WHERE id = $1",
      [id]
    );

    if (clientCheck.rows.length === 0) {
      throw AppError.notFound("Client not found");
    }

    const [appointments, purchases] = await Promise.all([
      // Get appointments from bookings table
      pool.query(
        `SELECT 
          b.id,
          b.booking_date as appointment_date,
          b.start_time,
          b.end_time,
          b.status,
          b.notes,
          s.name as treatment_name,
          s.price as treatment_price,
          s.duration_minutes
        FROM bookings b
        LEFT JOIN services s ON b.service_id = s.id
        WHERE b.client_id = $1
        ORDER BY b.booking_date DESC, b.start_time DESC
        LIMIT 50`,
        [id]
      ),

      // Get purchases
      pool.query(
        `SELECT 
          sl.id,
          sl.sale_date,
          sl.final_amount,
          sl.status,
          sl.receipt_number,
          json_agg(
            json_build_object(
              'name', COALESCE(p.name, s.name),
              'quantity', si.quantity,
              'price', si.unit_price,
              'type', CASE 
                WHEN si.product_id IS NOT NULL THEN 'product' 
                ELSE 'treatment' 
              END
            )
          ) as items
        FROM sales sl
        JOIN sale_items si ON sl.id = si.sale_id
        LEFT JOIN products p ON si.product_id = p.id
        LEFT JOIN services s ON si.service_id = s.id
        WHERE sl.client_id = $1
        GROUP BY sl.id
        ORDER BY sl.sale_date DESC
        LIMIT 50`,
        [id]
      ),
    ]);

    return {
      appointments: appointments.rows,
      purchases: purchases.rows,
    };
  }

  /**
   * Get client statistics
   * FIXED: Use 'bookings' and 'services' tables
   */
  async getStats(id: string) {
    const result = await pool.query(
      `SELECT 
        COUNT(DISTINCT b.id) as total_appointments,
        COUNT(DISTINCT b.id) FILTER (WHERE b.status = 'completed') as completed_appointments,
        COUNT(DISTINCT b.id) FILTER (WHERE b.status = 'cancelled') as cancelled_appointments,
        COUNT(DISTINCT b.id) FILTER (WHERE b.no_show = true) as no_shows,
        COUNT(DISTINCT s.id) as total_purchases,
        COALESCE(SUM(s.final_amount), 0) as total_spent,
        COALESCE(AVG(s.final_amount), 0) as average_purchase,
        MAX(b.booking_date) as last_visit,
        MIN(b.booking_date) as first_visit,
        array_agg(DISTINCT srv.name) FILTER (WHERE srv.name IS NOT NULL) as favorite_treatments
      FROM clients c
      LEFT JOIN bookings b ON c.id = b.client_id
      LEFT JOIN services srv ON b.service_id = srv.id
      LEFT JOIN sales s ON c.id = s.client_id
      WHERE c.id = $1
      GROUP BY c.id`,
      [id]
    );

    if (result.rows.length === 0) {
      throw AppError.notFound("Client not found");
    }

    const stats = result.rows[0];

    return {
      totalAppointments: parseInt(stats.total_appointments) || 0,
      completedAppointments: parseInt(stats.completed_appointments) || 0,
      cancelledAppointments: parseInt(stats.cancelled_appointments) || 0,
      noShows: parseInt(stats.no_shows) || 0,
      totalPurchases: parseInt(stats.total_purchases) || 0,
      totalSpent: parseFloat(stats.total_spent) || 0,
      averagePurchase: parseFloat(stats.average_purchase) || 0,
      lastVisit: stats.last_visit,
      firstVisit: stats.first_visit,
      favoriteTreatments: stats.favorite_treatments || [],
    };
  }

  /**
   * Soft delete client (mark as inactive)
   * FIXED: Use is_active
   */
  async delete(id: string) {
    const result = await pool.query(
      `UPDATE clients 
       SET is_active = false, updated_at = NOW()
       WHERE id = $1
       RETURNING id`,
      [id]
    );

    if (result.rows.length === 0) {
      throw AppError.notFound("Client not found");
    }

    logger.info(`Client deactivated: ${id}`);
  }

  /**
   * Format client object for response
   * FIXED: Use is_active
   */
  private formatClient(client: any) {
    return {
      id: client.id,
      name: `${client.first_name} ${client.last_name}`,
      firstName: client.first_name,
      lastName: client.last_name,
      email: client.email,
      phone: client.phone,
      whatsapp: client.whatsapp,
      notes: client.notes,
      dateOfBirth: client.date_of_birth,
      address: client.address,
      active: client.is_active !== false,
      totalAppointments: parseInt(client.total_appointments) || 0,
      completedAppointments: parseInt(client.completed_appointments) || 0,
      cancelledAppointments: parseInt(client.cancelled_appointments) || 0,
      noShows: parseInt(client.no_shows) || 0,
      totalPurchases: parseInt(client.total_purchases) || 0,
      lifetimeValue: parseFloat(client.lifetime_value) || 0,
      lastAppointmentDate: client.last_appointment_date,
      lastPurchaseDate: client.last_purchase_date,
      createdAt: client.created_at,
      updatedAt: client.updated_at,
    };
  }
}

export const clientService = new ClientService();


================================================================================
FILE: ./backend/src/services\inventory.service.ts
================================================================================



================================================================================
FILE: ./backend/src/services\product.service.ts
================================================================================

import { pool } from "../config/database.js";
import { Product } from "../types/index.js";
import AppError from "../utils/appError.js";
import { logger } from "../utils/logger.js";

export class ProductService {
  /**
   * Find all products with optional filtering
   */
  async findAll(filters: {
    category_id?: string;
    supplier_id?: string;
    active?: boolean;
    retail?: boolean;
    search?: string;
    page?: number;
    limit?: number;
    sort?: string;
  }) {
    try {
      const {
        category_id,
        supplier_id,
        active,
        retail,
        search,
        page = 1,
        limit = 50,
        sort = "created_at",
      } = filters;

      const params: any[] = [];
      let paramIndex = 1;
      const conditions: string[] = [];

      // Build WHERE conditions
      if (category_id) {
        conditions.push(`p.category_id = $${paramIndex++}`);
        params.push(category_id);
      }

      if (supplier_id) {
        conditions.push(`p.supplier_id = $${paramIndex++}`);
        params.push(supplier_id);
      }

      if (active !== undefined) {
        conditions.push(`p.active = $${paramIndex++}`);
        params.push(active);
      }

      if (retail !== undefined) {
        conditions.push(`p.retail = $${paramIndex++}`);
        params.push(retail);
      }

      if (search) {
        conditions.push(
          `(p.name ILIKE $${paramIndex} OR p.sku ILIKE $${paramIndex})`
        );
        params.push(`%${search}%`);
        paramIndex++;
      }

      const whereClause =
        conditions.length > 0 ? `WHERE ${conditions.join(" AND ")}` : "";

      // Build ORDER BY clause
      const sortMap: Record<string, string> = {
        name: "p.name",
        sku: "p.sku",
        created_at: "p.created_at",
        updated_at: "p.updated_at",
        price_cents: "p.price_cents",
        cost_cents: "p.cost_cents",
      };

      const sortDirection = sort.startsWith("-") ? "DESC" : "ASC";
      const sortField = sort.replace(/^-/, "");
      const orderBy = sortMap[sortField] || "p.created_at";

      // Pagination
      const offset = (page - 1) * limit;
      params.push(limit, offset);

      const query = `
        SELECT 
          p.*,
          c.name as category_name,
          s.name as supplier_name
        FROM products p
        LEFT JOIN categories c ON p.category_id = c.id
        LEFT JOIN suppliers s ON p.supplier_id = s.id
        ${whereClause}
        ORDER BY ${orderBy} ${sortDirection}
        LIMIT $${paramIndex} OFFSET $${paramIndex + 1}
      `;

      const [dataResult, countResult] = await Promise.all([
        pool.query(query, params),
        pool.query(
          `SELECT COUNT(*) FROM products p ${whereClause}`,
          params.slice(0, -2)
        ),
      ]);

      return {
        products: dataResult.rows,
        total: parseInt(countResult.rows[0].count),
        page,
        limit,
        totalPages: Math.ceil(parseInt(countResult.rows[0].count) / limit),
      };
    } catch (error) {
      logger.error("Error in ProductService.findAll:", error);
      throw error;
    }
  }

  /**
   * Find a product by ID with inventory details
   */
  async findById(id: string) {
    try {
      const result = await pool.query(
        `SELECT 
          p.*,
          c.name as category_name,
          s.name as supplier_name,
          json_agg(
            json_build_object(
              'location_id', il.location_id,
              'location_name', sl.name,
              'quantity_available', il.quantity_available,
              'quantity_reserved', il.quantity_reserved,
              'quantity_free', (il.quantity_available - il.quantity_reserved),
              'batch_number', il.batch_number,
              'expiry_date', il.expiry_date
            )
          ) FILTER (WHERE il.id IS NOT NULL) as inventory_levels
        FROM products p
        LEFT JOIN categories c ON p.category_id = c.id
        LEFT JOIN suppliers s ON p.supplier_id = s.id
        LEFT JOIN inventory_levels il ON p.id = il.product_id
        LEFT JOIN stock_locations sl ON il.location_id = sl.id
        WHERE p.id = $1
        GROUP BY p.id, c.name, s.name`,
        [id]
      );

      if (result.rows.length === 0) {
        throw new AppError("Product not found", 404);
      }

      return result.rows[0];
    } catch (error) {
      logger.error("Error in ProductService.findById:", error);
      throw error;
    }
  }

  /**
   * Create a new product
   */
  async create(data: {
    sku: string;
    name: string;
    category_id?: string | null;
    supplier_id?: string | null;
    cost_cents: number;
    price_cents: number;
    retail?: boolean;
    active?: boolean;
  }) {
    try {
      const result = await pool.query(
        `INSERT INTO products 
        (sku, name, category_id, supplier_id, cost_cents, price_cents, retail, active)
        VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
        RETURNING *`,
        [
          data.sku,
          data.name,
          data.category_id ?? null,
          data.supplier_id ?? null,
          data.cost_cents,
          data.price_cents,
          data.retail ?? false,
          data.active ?? true,
        ]
      );

      logger.info(`Product created: ${result.rows[0].id}`);
      return result.rows[0];
    } catch (error: any) {
      if (error.code === "23505") {
        throw new AppError("A product with this SKU already exists", 409);
      }
      logger.error("Error in ProductService.create:", error);
      throw error;
    }
  }

  /**
   * Update a product
   */
  async update(id: string, data: Partial<Product>) {
    try {
      const fields: string[] = [];
      const values: any[] = [];
      let paramIndex = 1;

      // Build SET clause dynamically
      const updateFields: Array<{ key: keyof Product; dbColumn: string }> = [
        { key: "sku", dbColumn: "sku" },
        { key: "name", dbColumn: "name" },
        { key: "category_id", dbColumn: "category_id" },
        { key: "supplier_id", dbColumn: "supplier_id" },
        { key: "cost_cents", dbColumn: "cost_cents" },
        { key: "price_cents", dbColumn: "price_cents" },
        { key: "retail", dbColumn: "retail" },
        { key: "active", dbColumn: "active" },
      ];

      for (const { key, dbColumn } of updateFields) {
        if (data[key] !== undefined) {
          fields.push(`${dbColumn} = $${paramIndex++}`);
          values.push(data[key]);
        }
      }

      if (fields.length === 0) {
        throw new AppError("No fields to update", 400);
      }

      values.push(id);

      const result = await pool.query(
        `UPDATE products 
        SET ${fields.join(", ")}, updated_at = CURRENT_TIMESTAMP
        WHERE id = $${paramIndex}
        RETURNING *`,
        values
      );

      if (result.rows.length === 0) {
        throw new AppError("Product not found", 404);
      }

      logger.info(`Product updated: ${id}`);
      return result.rows[0];
    } catch (error) {
      logger.error("Error in ProductService.update:", error);
      throw error;
    }
  }

  /**
   * Delete a product
   */
  async delete(id: string) {
    try {
      const result = await pool.query(
        "DELETE FROM products WHERE id = $1 RETURNING id",
        [id]
      );

      if (result.rows.length === 0) {
        throw new AppError("Product not found", 404);
      }

      logger.info(`Product deleted: ${id}`);
      return true;
    } catch (error: any) {
      if (error.code === "23503") {
        throw new AppError(
          "Cannot delete product as it has associated inventory records",
          400
        );
      }
      logger.error("Error in ProductService.delete:", error);
      throw error;
    }
  }
}

export const productService = new ProductService();


================================================================================
FILE: ./backend/src/services\staff.service.ts
================================================================================

import { pool } from '../config/database.js';
import AppError from '../utils/appError.js';
import { logger } from '../utils/logger.js';

interface CreateStaffData {
  name: string;
  email?: string;
  phone?: string;
  role: string;
  specializations?: string[];
  status?: "active" | "inactive" | "on_leave";
  hire_date?: string;
  bio?: string;
  certifications?: string[];
  schedule?: Record<string, string>;
  avatar?: string;
}

export class StaffService {
  /**
   * Find all staff members
   */
  async findAll(filters: {
    role?: string;
    status?: string;
    search?: string;
    page?: number;
    limit?: number;
  }) {
    const { role, status, search, page = 1, limit = 50 } = filters;
    const offset = (page - 1) * limit;

    const params: any[] = [];
    let paramIndex = 1;
    const conditions: string[] = [];

    if (role) {
      conditions.push(`role = $${paramIndex++}`);
      params.push(role);
    }

    if (status) {
      conditions.push(`status = $${paramIndex++}`);
      params.push(status);
    }

    if (search) {
      conditions.push(
        `(name ILIKE $${paramIndex} OR email ILIKE $${paramIndex})`
      );
      params.push(`%${search}%`);
      paramIndex++;
    }

    const whereClause =
      conditions.length > 0 ? `WHERE ${conditions.join(" AND ")}` : "";

    params.push(limit, offset);

    const query = `
      SELECT * FROM staff
      ${whereClause}
      ORDER BY name ASC
      LIMIT $${paramIndex} OFFSET $${paramIndex + 1}
    `;

    const countQuery = `SELECT COUNT(*) FROM staff ${whereClause}`;

    const [dataResult, countResult] = await Promise.all([
      pool.query(query, params),
      pool.query(countQuery, params.slice(0, -2)),
    ]);

    return {
      staff: dataResult.rows,
      total: parseInt(countResult.rows[0].count),
      page,
      limit,
      totalPages: Math.ceil(parseInt(countResult.rows[0].count) / limit),
    };
  }

  /**
   * Find staff by ID
   */
  async findById(id: string) {
    const result = await pool.query("SELECT * FROM staff WHERE id = $1", [id]);

    if (result.rows.length === 0) {
      throw AppError.notFound("Staff member not found");
    }

    return result.rows[0];
  }

  /**
   * Create new staff member
   */
  async create(data: CreateStaffData) {
    const result = await pool.query(
      `INSERT INTO staff (
        name, email, phone, role, specializations, status,
        hire_date, bio, certifications, schedule, avatar
      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
      RETURNING *`,
      [
        data.name,
        data.email || null,
        data.phone || null,
        data.role,
        data.specializations || [],
        data.status || "active",
        data.hire_date || null,
        data.bio || null,
        data.certifications || [],
        data.schedule ? JSON.stringify(data.schedule) : null,
        data.avatar || null,
      ]
    );

    logger.info(`Staff member created: ${result.rows[0].id}`);
    return result.rows[0];
  }

  /**
   * Update staff member
   */
  async update(id: string, data: Partial<CreateStaffData>) {
    const fields: string[] = [];
    const values: any[] = [];
    let paramIndex = 1;

    const fieldMap: Record<string, string> = {
      name: "name",
      email: "email",
      phone: "phone",
      role: "role",
      specializations: "specializations",
      status: "status",
      hire_date: "hire_date",
      bio: "bio",
      certifications: "certifications",
      schedule: "schedule",
      avatar: "avatar",
    };

    for (const [key, dbField] of Object.entries(fieldMap)) {
      if (data[key as keyof CreateStaffData] !== undefined) {
        let value = data[key as keyof CreateStaffData];
        if (key === "schedule" && value) {
          value = JSON.stringify(value);
        }
        fields.push(`${dbField} = $${paramIndex++}`);
        values.push(value);
      }
    }

    if (fields.length === 0) {
      throw AppError.badRequest("No fields to update");
    }

    values.push(id);

    const result = await pool.query(
      `UPDATE staff
       SET ${fields.join(", ")}, updated_at = NOW()
       WHERE id = $${paramIndex}
       RETURNING *`,
      values
    );

    if (result.rows.length === 0) {
      throw AppError.notFound("Staff member not found");
    }

    logger.info(`Staff member updated: ${id}`);
    return result.rows[0];
  }

  /**
   * Delete staff member
   */
  async delete(id: string) {
    const result = await pool.query(
      "UPDATE staff SET status = 'inactive' WHERE id = $1 RETURNING id",
      [id]
    );

    if (result.rows.length === 0) {
      throw AppError.notFound("Staff member not found");
    }

    logger.info(`Staff member deactivated: ${id}`);
  }

  /**
   * Get staff performance
   */
  async getPerformance(id: string, period: string) {
    const result = await pool.query(
      `SELECT 
        s.id as staff_id,
        $2 as period,
        COUNT(DISTINCT a.id) FILTER (WHERE a.status = 'completed') as appointments_completed,
        COUNT(DISTINCT a.id) FILTER (WHERE a.status = 'cancelled') as appointments_cancelled,
        COALESCE(SUM(sale.final_amount), 0) as total_revenue,
        COUNT(DISTINCT a.id) FILTER (WHERE a.status = 'no_show') as no_shows
      FROM staff s
      LEFT JOIN appointments a ON s.id = a.staff_id
      LEFT JOIN sales sale ON a.id = sale.appointment_id
      WHERE s.id = $1
      GROUP BY s.id`,
      [id, period]
    );

    if (result.rows.length === 0) {
      throw AppError.notFound("Staff member not found");
    }

    return result.rows[0];
  }
}

export const staffService = new StaffService();


================================================================================
FILE: ./backend/src/services\stock.service.ts
================================================================================

import { pool } from '../config/database.js';
import AppError from '../utils/appError.js';
import { logger } from '../utils/logger.js';

type StockLocation = "retail" | "treatment" | "storage";

interface CreateStockItemData {
  name: string;
  sku?: string;
  category?: string;
  location: StockLocation;
  quantity: number;
  min_quantity?: number;
  unit?: string;
  cost?: number;
  retail_price?: number;
  supplier?: string;
  notes?: string;
}

interface TransferStockData {
  item_id: string;
  from_location: StockLocation;
  to_location: StockLocation;
  quantity: number;
  notes?: string;
}

export class StockService {
  /**
   * Find all stock items
   */
  async findAll(filters: {
    location?: StockLocation;
    category?: string;
    low_stock?: boolean;
    search?: string;
    page?: number;
    limit?: number;
  }) {
    const {
      location,
      category,
      low_stock,
      search,
      page = 1,
      limit = 50,
    } = filters;
    const offset = (page - 1) * limit;

    const params: any[] = [];
    let paramIndex = 1;
    const conditions: string[] = [];

    if (location) {
      conditions.push(`location = $${paramIndex++}`);
      params.push(location);
    }

    if (category) {
      conditions.push(`category = $${paramIndex++}`);
      params.push(category);
    }

    if (low_stock) {
      conditions.push(`quantity <= min_quantity`);
    }

    if (search) {
      conditions.push(
        `(name ILIKE $${paramIndex} OR sku ILIKE $${paramIndex})`
      );
      params.push(`%${search}%`);
      paramIndex++;
    }

    const whereClause =
      conditions.length > 0 ? `WHERE ${conditions.join(" AND ")}` : "";

    params.push(limit, offset);

    const query = `
      SELECT * FROM stock_items
      ${whereClause}
      ORDER BY name ASC
      LIMIT $${paramIndex} OFFSET $${paramIndex + 1}
    `;

    const countQuery = `SELECT COUNT(*) FROM stock_items ${whereClause}`;

    const [dataResult, countResult] = await Promise.all([
      pool.query(query, params),
      pool.query(countQuery, params.slice(0, -2)),
    ]);

    return {
      items: dataResult.rows,
      total: parseInt(countResult.rows[0].count),
      page,
      limit,
      totalPages: Math.ceil(parseInt(countResult.rows[0].count) / limit),
    };
  }

  /**
   * Find stock item by ID
   */
  async findById(id: string) {
    const result = await pool.query("SELECT * FROM stock_items WHERE id = $1", [
      id,
    ]);

    if (result.rows.length === 0) {
      throw AppError.notFound("Stock item not found");
    }

    return result.rows[0];
  }

  /**
   * Create new stock item
   */
  async create(data: CreateStockItemData) {
    const result = await pool.query(
      `INSERT INTO stock_items (
        name, sku, category, location, quantity, min_quantity,
        unit, cost, retail_price, supplier, notes, last_restocked
      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, NOW())
      RETURNING *`,
      [
        data.name,
        data.sku || null,
        data.category || null,
        data.location,
        data.quantity,
        data.min_quantity || 0,
        data.unit || null,
        data.cost || null,
        data.retail_price || null,
        data.supplier || null,
        data.notes || null,
      ]
    );

    logger.info(`Stock item created: ${result.rows[0].id}`);
    return result.rows[0];
  }

  /**
   * Update stock item
   */
  async update(id: string, data: Partial<CreateStockItemData>) {
    const fields: string[] = [];
    const values: any[] = [];
    let paramIndex = 1;

    const fieldMap: Record<string, string> = {
      name: "name",
      sku: "sku",
      category: "category",
      location: "location",
      quantity: "quantity",
      min_quantity: "min_quantity",
      unit: "unit",
      cost: "cost",
      retail_price: "retail_price",
      supplier: "supplier",
      notes: "notes",
    };

    for (const [key, dbField] of Object.entries(fieldMap)) {
      if (data[key as keyof CreateStockItemData] !== undefined) {
        fields.push(`${dbField} = $${paramIndex++}`);
        values.push(data[key as keyof CreateStockItemData]);
      }
    }

    if (fields.length === 0) {
      throw AppError.badRequest("No fields to update");
    }

    values.push(id);

    const result = await pool.query(
      `UPDATE stock_items
       SET ${fields.join(", ")}, updated_at = NOW()
       WHERE id = $${paramIndex}
       RETURNING *`,
      values
    );

    if (result.rows.length === 0) {
      throw AppError.notFound("Stock item not found");
    }

    logger.info(`Stock item updated: ${id}`);
    return result.rows[0];
  }

  /**
   * Transfer stock between locations
   */
  async transfer(data: TransferStockData) {
    const client = await pool.connect();

    try {
      await client.query("BEGIN");

      // Check if item exists at source location
      const sourceCheck = await client.query(
        "SELECT quantity FROM stock_items WHERE id = $1 AND location = $2",
        [data.item_id, data.from_location]
      );

      if (sourceCheck.rows.length === 0) {
        throw AppError.notFound("Item not found at source location");
      }

      if (sourceCheck.rows[0].quantity < data.quantity) {
        throw AppError.badRequest("Insufficient quantity at source location");
      }

      // Decrease quantity at source
      await client.query(
        "UPDATE stock_items SET quantity = quantity - $1 WHERE id = $2 AND location = $3",
        [data.quantity, data.item_id, data.from_location]
      );

      // Check if item exists at destination
      const destCheck = await client.query(
        "SELECT id FROM stock_items WHERE id = $1 AND location = $2",
        [data.item_id, data.to_location]
      );

      if (destCheck.rows.length > 0) {
        // Increase quantity at destination
        await client.query(
          "UPDATE stock_items SET quantity = quantity + $1 WHERE id = $2 AND location = $3",
          [data.quantity, data.item_id, data.to_location]
        );
      } else {
        // Create new entry at destination (would need item details)
        throw AppError.badRequest("Destination location entry does not exist");
      }

      // Log the transfer
      await client.query(
        `INSERT INTO stock_transfers (
          item_id, from_location, to_location, quantity, notes, transferred_at
        ) VALUES ($1, $2, $3, $4, $5, NOW())`,
        [
          data.item_id,
          data.from_location,
          data.to_location,
          data.quantity,
          data.notes || null,
        ]
      );

      await client.query("COMMIT");
      logger.info(
        `Stock transferred: ${data.item_id} from ${data.from_location} to ${data.to_location}`
      );

      return { success: true };
    } catch (error) {
      await client.query("ROLLBACK");
      throw error;
    } finally {
      client.release();
    }
  }

  /**
   * Delete stock item
   */
  async delete(id: string) {
    const result = await pool.query(
      "DELETE FROM stock_items WHERE id = $1 RETURNING id",
      [id]
    );

    if (result.rows.length === 0) {
      throw AppError.notFound("Stock item not found");
    }

    logger.info(`Stock item deleted: ${id}`);
  }
}

export const stockService = new StockService();


================================================================================
FILE: ./backend/src/services\transaction.service.ts
================================================================================

import { pool } from '../config/database.js';
import AppError from '../utils/appError.js';
import { logger } from '../utils/logger.js';

interface CreateTransactionData {
  client_id?: string;
  items: any[];
  subtotal: number;
  discount: {
    type: string;
    value: number;
    reason?: string;
  };
  discount_amount: number;
  tax: number;
  tips: Record<string, number>;
  tips_total: number;
  total: number;
  payments: any[];
  payment_method: string;
  loyalty_points_earned: number;
  loyalty_points_redeemed: number;
  status: string;
  created_by: string;
}

export class TransactionService {
  /**
   * Find all transactions
   */
  async findAll(filters: {
    client_id?: string;
    status?: string;
    date_from?: string;
    date_to?: string;
    page?: number;
    limit?: number;
  }) {
    const {
      client_id,
      status,
      date_from,
      date_to,
      page = 1,
      limit = 50,
    } = filters;
    const offset = (page - 1) * limit;

    const params: any[] = [];
    let paramIndex = 1;
    const conditions: string[] = [];

    if (client_id) {
      conditions.push(`client_id = $${paramIndex++}`);
      params.push(client_id);
    }

    if (status) {
      conditions.push(`status = $${paramIndex++}`);
      params.push(status);
    }

    if (date_from) {
      conditions.push(`created_at >= $${paramIndex++}`);
      params.push(date_from);
    }

    if (date_to) {
      conditions.push(`created_at <= $${paramIndex++}`);
      params.push(date_to);
    }

    const whereClause =
      conditions.length > 0 ? `WHERE ${conditions.join(" AND ")}` : "";

    params.push(limit, offset);

    const query = `
      SELECT * FROM transactions
      ${whereClause}
      ORDER BY created_at DESC
      LIMIT $${paramIndex} OFFSET $${paramIndex + 1}
    `;

    const countQuery = `SELECT COUNT(*) FROM transactions ${whereClause}`;

    const [dataResult, countResult] = await Promise.all([
      pool.query(query, params),
      pool.query(countQuery, params.slice(0, -2)),
    ]);

    return {
      transactions: dataResult.rows,
      total: parseInt(countResult.rows[0].count),
      page,
      limit,
      totalPages: Math.ceil(parseInt(countResult.rows[0].count) / limit),
    };
  }

  /**
   * Find transaction by ID
   */
  async findById(id: string) {
    const result = await pool.query(
      "SELECT * FROM transactions WHERE id = $1",
      [id]
    );

    if (result.rows.length === 0) {
      throw AppError.notFound("Transaction not found");
    }

    return result.rows[0];
  }

  /**
   * Create new transaction
   */
  async create(data: CreateTransactionData) {
    const result = await pool.query(
      `INSERT INTO transactions (
        client_id, items, subtotal, discount, discount_amount, tax,
        tips, tips_total, total, payments, payment_method,
        loyalty_points_earned, loyalty_points_redeemed, status, created_by
      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15)
      RETURNING *`,
      [
        data.client_id || null,
        JSON.stringify(data.items),
        data.subtotal,
        JSON.stringify(data.discount),
        data.discount_amount,
        data.tax,
        JSON.stringify(data.tips),
        data.tips_total,
        data.total,
        JSON.stringify(data.payments),
        data.payment_method,
        data.loyalty_points_earned,
        data.loyalty_points_redeemed,
        data.status,
        data.created_by,
      ]
    );

    logger.info(`Transaction created: ${result.rows[0].id}`);
    return result.rows[0];
  }

  /**
   * Update transaction
   */
  async update(id: string, data: Partial<CreateTransactionData>) {
    const fields: string[] = [];
    const values: any[] = [];
    let paramIndex = 1;

    if (data.status) {
      fields.push(`status = $${paramIndex++}`);
      values.push(data.status);
    }

    if (fields.length === 0) {
      throw AppError.badRequest("No fields to update");
    }

    values.push(id);

    const result = await pool.query(
      `UPDATE transactions
       SET ${fields.join(", ")}, updated_at = NOW()
       WHERE id = $${paramIndex}
       RETURNING *`,
      values
    );

    if (result.rows.length === 0) {
      throw AppError.notFound("Transaction not found");
    }

    logger.info(`Transaction updated: ${id}`);
    return result.rows[0];
  }
}

export const transactionService = new TransactionService();


================================================================================
FILE: ./backend/src/services\treatment.service.ts
================================================================================

import { pool } from '../config/database.js';
import AppError from '../utils/appError.js';
import { logger } from '../utils/logger.js';

interface CreateTreatmentData {
  name: string;
  description?: string;
  duration_minutes: number;
  price: number;
  category?: string;
  benefits?: string[];
  contraindications?: string[];
  preparation_instructions?: string;
  aftercare_instructions?: string;
  available_for?: string[];
  image_url?: string;
  is_active?: boolean;
  tags?: string[];
}

export class TreatmentService {
  /**
   * Find all treatments with filters
   */
  async findAll(filters: {
    category?: string;
    is_active?: boolean;
    search?: string;
    page?: number;
    limit?: number;
  }) {
    const { category, is_active, search, page = 1, limit = 50 } = filters;
    const offset = (page - 1) * limit;

    const params: any[] = [];
    let paramIndex = 1;
    const conditions: string[] = [];

    if (category) {
      conditions.push(`category = $${paramIndex++}`);
      params.push(category);
    }

    if (is_active !== undefined) {
      conditions.push(`is_active = $${paramIndex++}`);
      params.push(is_active);
    }

    if (search) {
      conditions.push(
        `(name ILIKE $${paramIndex} OR description ILIKE $${paramIndex})`
      );
      params.push(`%${search}%`);
      paramIndex++;
    }

    const whereClause =
      conditions.length > 0 ? `WHERE ${conditions.join(" AND ")}` : "";

    params.push(limit, offset);

    const query = `
      SELECT * FROM treatments
      ${whereClause}
      ORDER BY popularity_score DESC NULLS LAST, name ASC
      LIMIT $${paramIndex} OFFSET $${paramIndex + 1}
    `;

    const countQuery = `SELECT COUNT(*) FROM treatments ${whereClause}`;

    const [dataResult, countResult] = await Promise.all([
      pool.query(query, params),
      pool.query(countQuery, params.slice(0, -2)),
    ]);

    return {
      treatments: dataResult.rows,
      total: parseInt(countResult.rows[0].count),
      page,
      limit,
      totalPages: Math.ceil(parseInt(countResult.rows[0].count) / limit),
    };
  }

  /**
   * Find treatment by ID
   */
  async findById(id: string) {
    const result = await pool.query("SELECT * FROM treatments WHERE id = $1", [
      id,
    ]);

    if (result.rows.length === 0) {
      throw AppError.notFound("Treatment not found");
    }

    return result.rows[0];
  }

  /**
   * Create new treatment
   */
  async create(data: CreateTreatmentData) {
    const result = await pool.query(
      `INSERT INTO treatments (
        name, description, duration_minutes, price, category,
        benefits, contraindications, preparation_instructions,
        aftercare_instructions, available_for, image_url, is_active, tags
      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13)
      RETURNING *`,
      [
        data.name,
        data.description || null,
        data.duration_minutes,
        data.price,
        data.category || null,
        data.benefits || [],
        data.contraindications || [],
        data.preparation_instructions || null,
        data.aftercare_instructions || null,
        data.available_for || [],
        data.image_url || null,
        data.is_active !== false,
        data.tags || [],
      ]
    );

    logger.info(`Treatment created: ${result.rows[0].id}`);
    return result.rows[0];
  }

  /**
   * Update treatment
   */
  async update(id: string, data: Partial<CreateTreatmentData>) {
    const fields: string[] = [];
    const values: any[] = [];
    let paramIndex = 1;

    const fieldMap: Record<string, string> = {
      name: "name",
      description: "description",
      duration_minutes: "duration_minutes",
      price: "price",
      category: "category",
      benefits: "benefits",
      contraindications: "contraindications",
      preparation_instructions: "preparation_instructions",
      aftercare_instructions: "aftercare_instructions",
      available_for: "available_for",
      image_url: "image_url",
      is_active: "is_active",
      tags: "tags",
    };

    for (const [key, dbField] of Object.entries(fieldMap)) {
      if (data[key as keyof CreateTreatmentData] !== undefined) {
        fields.push(`${dbField} = $${paramIndex++}`);
        values.push(data[key as keyof CreateTreatmentData]);
      }
    }

    if (fields.length === 0) {
      throw AppError.badRequest("No fields to update");
    }

    values.push(id);

    const result = await pool.query(
      `UPDATE treatments
       SET ${fields.join(", ")}, updated_at = NOW()
       WHERE id = $${paramIndex}
       RETURNING *`,
      values
    );

    if (result.rows.length === 0) {
      throw AppError.notFound("Treatment not found");
    }

    logger.info(`Treatment updated: ${id}`);
    return result.rows[0];
  }

  /**
   * Delete treatment
   */
  async delete(id: string) {
    const result = await pool.query(
      "UPDATE treatments SET is_active = false WHERE id = $1 RETURNING id",
      [id]
    );

    if (result.rows.length === 0) {
      throw AppError.notFound("Treatment not found");
    }

    logger.info(`Treatment deactivated: ${id}`);
  }
}

export const treatmentService = new TreatmentService();
