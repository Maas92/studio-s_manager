Code combined from: C:\Users\p01mansoorg\Documents\python\Studio-S_manager\auth\src
================================================================================



================================================================================
FILE: auth/src\app.ts
================================================================================

import express, { Application, Request, Response, NextFunction } from "express";
import bodyParser from "body-parser";
import morgan from "morgan";
import helmet from "helmet";
import hpp from "hpp";
import cookieParser from "cookie-parser";
import compression from "compression";
import cors from "cors";

import { env, isDevelopment } from "./config/env.js";
import { getPublicJwks } from "./config/jwt.js";
import authRouter from "./routes/authRoutes.js";
import userRouter from "./routes/userRoutes.js";
import AppError from "./utils/appError.js";
import globalErrorHandler from "./controllers/errorController.js";
import { globalLimiter } from "./middleware/rateLimiter.js";
import { logger } from "./utils/logger.js";
import { mongoSanitize } from "./middleware/sanitize.js";

const app: Application = express();

// Trust proxy (for rate limiting and IP detection)
app.set("trust proxy", env.TRUST_PROXY);

// CORS configuration
app.use(
  cors({
    origin: env.CORS_ORIGIN,
    credentials: true,
    methods: ["GET", "POST", "PUT", "PATCH", "DELETE", "OPTIONS"],
    allowedHeaders: ["Content-Type", "Authorization"],
  })
);

// Security HTTP headers
app.use(
  helmet({
    crossOriginResourcePolicy: { policy: "cross-origin" },
  })
);

// Development logging
if (isDevelopment) {
  app.use(morgan("dev"));
} else {
  app.use(
    morgan("combined", {
      stream: {
        write: (message) => logger.info(message.trim()),
      },
    })
  );
}

// Body parser
app.use(bodyParser.json({ limit: "10kb" }));

// Cookie parser
app.use(cookieParser());

// Data sanitization against NoSQL query injection
app.use(
  mongoSanitize({
    onSanitize: "error", // or "remove" to silently remove
    logAttempts: true,
  })
);

// Prevent parameter pollution
app.use(
  hpp({
    whitelist: ["role", "specializations"],
  })
);

// Compression
app.use(compression());

// Request timestamp
app.use((req: Request, res: Response, next: NextFunction) => {
  req.requestTime = new Date().toISOString();
  next();
});

// JWKS endpoint
app.get("/.well-known/jwks.json", (req: Request, res: Response) => {
  res.json(getPublicJwks());
});

// Health check
app.get("/health", (req: Request, res: Response) => {
  res.json({
    status: "ok",
    service: "auth",
    timestamp: new Date().toISOString(),
    uptime: process.uptime(),
  });
});

// API routes
app.use("/", authRouter);
app.use("/api/v1/users", globalLimiter, userRouter);

// 404 handler
app.use((req: Request, res: Response, next: NextFunction) => {
  next(AppError.notFound(`Cannot find ${req.originalUrl} on this server`));
});

// Global error handler
app.use(globalErrorHandler);

export default app;


================================================================================
FILE: auth/src\server.ts
================================================================================

import app from "./app.js";
import { env, isProduction } from "./config/env.js";
import { connectDatabase, disconnectDatabase } from "./config/database.js";
import { initKeys } from "./config/jwt.js";
import { logger } from "./utils/logger.js";
import { tokenService } from "./services/tokenService.js";

// Handle uncaught exceptions
process.on("uncaughtException", (err: Error) => {
  logger.error("UNCAUGHT EXCEPTION! Shutting down...", {
    error: err.name,
    message: err.message,
    stack: err.stack,
  });
  process.exit(1);
});

let server: any;

async function bootstrap() {
  try {
    // Initialize JWT keys
    await initKeys();
    logger.info("JWT keys initialized");

    // Connect to database
    await connectDatabase();

    // Start session cleanup job (every hour)
    setInterval(async () => {
      try {
        await tokenService.cleanupExpiredSessions();
      } catch (error) {
        logger.error("Session cleanup error:", error);
      }
    }, 60 * 60 * 1000); // 1 hour

    // Start server
    server = app.listen(env.PORT, () => {
      logger.info(`üöÄ Auth service running on port ${env.PORT}`);
      logger.info(`Environment: ${env.NODE_ENV}`);
      logger.info(`CORS origin: ${env.CORS_ORIGIN}`);
    });
  } catch (error) {
    logger.error("Bootstrap error:", error);
    process.exit(1);
  }
}

// Handle unhandled promise rejections
process.on("unhandledRejection", (err: Error) => {
  logger.error("UNHANDLED REJECTION! Shutting down...", {
    error: err.name,
    message: err.message,
    stack: err.stack,
  });

  if (server) {
    server.close(async () => {
      await disconnectDatabase();
      process.exit(1);
    });
  } else {
    process.exit(1);
  }
});

// Handle SIGTERM
process.on("SIGTERM", () => {
  logger.info("SIGTERM received. Shutting down gracefully...");

  if (server) {
    server.close(async () => {
      logger.info("HTTP server closed");
      await disconnectDatabase();
      logger.info("Process terminated");
      process.exit(0);
    });
  }
});

// Handle SIGINT (Ctrl+C)
process.on("SIGINT", () => {
  logger.info("SIGINT received. Shutting down gracefully...");

  if (server) {
    server.close(async () => {
      logger.info("HTTP server closed");
      await disconnectDatabase();
      logger.info("Process terminated");
      process.exit(0);
    });
  }
});

// Start the application
bootstrap();


================================================================================
FILE: auth/src\config\database.ts
================================================================================

import mongoose from "mongoose";
import { env } from "./env.js";
import { logger } from "../utils/logger.js";

export async function connectDatabase(): Promise<void> {
  try {
    await mongoose.connect(env.MONGODB_URI, {
      maxPoolSize: 10,
      minPoolSize: 5,
      socketTimeoutMS: 45000,
      serverSelectionTimeoutMS: 5000,
    });

    logger.info("‚úÖ MongoDB connected successfully");

    mongoose.connection.on("error", (err) => {
      logger.error("MongoDB connection error:", err);
    });

    mongoose.connection.on("disconnected", () => {
      logger.warn("MongoDB disconnected");
    });
  } catch (error) {
    logger.error("‚ùå MongoDB connection failed:", error);
    throw error;
  }
}

export async function disconnectDatabase(): Promise<void> {
  await mongoose.connection.close();
  logger.info("MongoDB connection closed");
}


================================================================================
FILE: auth/src\config\env.ts
================================================================================

import { z } from "zod";
import "dotenv/config";

const envSchema = z.object({
  NODE_ENV: z
    .enum(["development", "production", "test"])
    .default("development"),
  PORT: z.string().transform(Number).default(5002),

  // MongoDB
  MONGODB_URI: z.string().min(1, "MONGODB_URI is required"),

  // JWT
  JWT_ISSUER: z.string().default("studio-s-auth"),
  JWT_AUDIENCE: z.string().default("studio-s-clients"),
  JWT_KID: z.string().default("studio-s-auth-1"),
  JWT_PRIVATE_PEM: z.string().optional(),
  JWT_PUBLIC_PEM: z.string().optional(),
  ACCESS_TOKEN_TTL_SEC: z.string().transform(Number).default(900),
  REFRESH_TOKEN_TTL_SEC: z.string().transform(Number).default(1209600),

  // Cookie settings
  COOKIE_DOMAIN: z.string().default("localhost"),
  COOKIE_SECURE: z
    .string()
    .transform((val) => val === "true")
    .default(false),
  COOKIE_SAMESITE: z.enum(["lax", "strict", "none"]).default("lax"),
  TRUST_PROXY: z.enum(["true", "false", "loopback"]).default("false"),

  // CORS
  CORS_ORIGIN: z.string().default("http://localhost:5173"),

  // JWKS
  SELF_JWKS_URL: z
    .string()
    .url()
    .default("http://localhost:5002/.well-known/jwks.json"),

  // Logging
  LOG_LEVEL: z.enum(["error", "warn", "info", "debug"]).default("info"),
});

export type Environment = z.infer<typeof envSchema>;

export const env = envSchema.parse(process.env);

// Export commonly used values
export const isProduction = env.NODE_ENV === "production";
export const isDevelopment = env.NODE_ENV === "development";
export const isTest = env.NODE_ENV === "test";


================================================================================
FILE: auth/src\config\jwt.ts
================================================================================

import {
  generateKeyPair,
  exportJWK,
  importPKCS8,
  importSPKI,
  SignJWT,
  jwtVerify,
  JWTPayload,
  JWK,
} from "jose";
import { env } from "./env.js";
import { logger } from "../utils/logger.js";

let privateKey: CryptoKey | undefined;
let publicKey: CryptoKey | undefined;
let publicJwk: JWK | undefined;

export async function initKeys(): Promise<void> {
  try {
    if (env.JWT_PRIVATE_PEM && env.JWT_PUBLIC_PEM) {
      // Import both private and public keys from env (production)
      privateKey = await importPKCS8(env.JWT_PRIVATE_PEM, "RS256");
      publicKey = await importSPKI(env.JWT_PUBLIC_PEM, "RS256");
      publicJwk = await exportJWK(publicKey);
      logger.info("Imported JWT private and public keys from environment");
    } else if (env.JWT_PRIVATE_PEM && !env.JWT_PUBLIC_PEM) {
      // If only private provided, fail loudly in prod ‚Äî better to require public as well.
      logger.warn(
        "JWT_PRIVATE_PEM provided but JWT_PUBLIC_PEM missing. This is unsafe; generating new pair (dev fallback)."
      );
      const kp = await generateKeyPair("RS256", { modulusLength: 2048 });
      privateKey = await importPKCS8(env.JWT_PRIVATE_PEM, "RS256");
      // Use generated public key to verify ‚Äî but note: generated public won't match imported private.
      // This fallback is strictly for dev; in prod you must provide matching public key.
      publicKey = kp.publicKey;
      publicJwk = await exportJWK(publicKey);
    } else {
      // Development: generate key pair
      logger.warn("Generating new JWT keys (development only)");
      const kp = await generateKeyPair("RS256", { modulusLength: 2048 });
      privateKey = kp.privateKey;
      publicKey = kp.publicKey;
      publicJwk = await exportJWK(publicKey);
    }

    // Ensure JWK metadata
    if (!publicJwk) {
      throw new Error("Public JWK not initialized");
    }
    publicJwk.alg = "RS256";
    publicJwk.use = "sig";
    publicJwk.kid = env.JWT_KID || publicJwk.kid || "dev-key";

    logger.info("JWT keys initialized successfully");
  } catch (error) {
    logger.error("Failed to initialize JWT keys:", error);
    throw error;
  }
}

export function getPublicJwks(): { keys: any[] } {
  if (!publicJwk) {
    throw new Error("Public JWK not initialized");
  }
  return { keys: [publicJwk] };
}

export function getPrivateKey(): CryptoKey {
  if (!privateKey) {
    throw new Error("Private key not initialized");
  }
  return privateKey;
}

export function getPublicKey(): CryptoKey {
  if (!publicKey) {
    throw new Error("Public key not initialized");
  }
  return publicKey;
}

export async function signToken(
  payload: JWTPayload,
  expiresIn: string
): Promise<string> {
  if (!privateKey) throw new Error("Private key not initialized");
  return await new SignJWT(payload)
    .setProtectedHeader({ alg: "RS256", kid: publicJwk?.kid })
    .setIssuedAt()
    .setExpirationTime(expiresIn)
    .setIssuer(env.JWT_ISSUER)
    .setAudience(env.JWT_AUDIENCE)
    .sign(privateKey);
}

export async function verifyToken(token: string): Promise<{
  payload: JWTPayload;
  protectedHeader: any;
}> {
  if (!publicKey) throw new Error("Public key not initialized");
  return await jwtVerify(token, publicKey, {
    issuer: env.JWT_ISSUER,
    audience: env.JWT_AUDIENCE,
  });
}


================================================================================
FILE: auth/src\controllers\authController.ts
================================================================================

import { Request, Response, NextFunction } from "express";
import { authService } from "../services/authService.js";
import { tokenService } from "../services/tokenService.js";
import catchAsync from "../utils/catchAsync.js";
import AppError from "../utils/appError.js";
import { env } from "../config/env.js";
import { logger } from "../utils/logger.js";

// Get cookie domain (undefined for localhost to avoid issues)
const getCookieDomain = () => {
  return env.COOKIE_DOMAIN === "localhost" ? undefined : env.COOKIE_DOMAIN;
};

// Set access token cookie (for authentication)
function setAccessTokenCookie(res: Response, token: string): void {
  res.cookie("jwt", token, {
    httpOnly: true,
    secure: env.COOKIE_SECURE,
    sameSite: env.COOKIE_SAMESITE,
    path: "/", // CRITICAL: Must be "/" to send to all routes
    maxAge: env.ACCESS_TOKEN_TTL_SEC * 1000,
    domain: getCookieDomain(),
  });
}

// Set refresh token cookie (for token refresh only)
function setRefreshTokenCookie(res: Response, token: string): void {
  res.cookie("refreshToken", token, {
    httpOnly: true,
    secure: env.COOKIE_SECURE,
    sameSite: env.COOKIE_SAMESITE,
    path: "/", // Changed from "/api/v1/auth/refresh" to "/"
    maxAge: env.REFRESH_TOKEN_TTL_SEC * 1000,
    domain: getCookieDomain(),
  });
}

// Clear both cookies on logout
function clearAuthCookies(res: Response): void {
  const cookieOptions = {
    httpOnly: true,
    secure: env.COOKIE_SECURE,
    sameSite: env.COOKIE_SAMESITE,
    path: "/",
    domain: getCookieDomain(),
  };

  res.clearCookie("jwt", cookieOptions);
  res.clearCookie("refreshToken", cookieOptions);
}

/**
 * POST /auth/signup
 */
export const signup = catchAsync(
  async (req: Request, res: Response, next: NextFunction) => {
    const { user, accessToken, refreshToken } = await authService.signup(
      req.body
    );

    // Set both cookies
    setAccessTokenCookie(res, accessToken);
    setRefreshTokenCookie(res, refreshToken);

    res.status(201).json({
      status: "success",
      data: {
        user: {
          id: user._id,
          email: user.email,
          role: user.role,
          name: user.name,
          firstName: user.firstName,
          lastName: user.lastName,
        },
      },
    });
  }
);

/**
 * POST /auth/login
 */
export const login = catchAsync(
  async (req: Request, res: Response, next: NextFunction) => {
    const ip = req.ip;
    const userAgent = req.get("user-agent");

    const { user, accessToken, refreshToken } = await authService.login(
      req.body,
      ip,
      userAgent
    );

    // Set both cookies
    setAccessTokenCookie(res, accessToken);
    setRefreshTokenCookie(res, refreshToken);

    res.status(200).json({
      status: "success",
      data: {
        user: {
          id: user._id,
          email: user.email,
          role: user.role,
          name: user.name,
          firstName: user.firstName,
          lastName: user.lastName,
          lastLogin: user.lastLogin,
        },
      },
    });
  }
);

/**
 * POST /auth/refresh
 */
export const refresh = catchAsync(
  async (req: Request, res: Response, next: NextFunction) => {
    const refreshToken = req.cookies?.refreshToken;

    if (!refreshToken) {
      throw AppError.unauthorized("Refresh token not found");
    }

    const ip = req.ip;
    const userAgent = req.get("user-agent");

    const { accessToken, refreshToken: newRefreshToken } =
      await authService.refreshTokens(refreshToken, ip, userAgent);

    // Set new cookies
    setAccessTokenCookie(res, accessToken);
    setRefreshTokenCookie(res, newRefreshToken);

    res.status(200).json({
      status: "success",
      message: "Tokens refreshed successfully",
    });
  }
);

/**
 * POST /auth/logout
 */
export const logout = catchAsync(
  async (req: Request, res: Response, next: NextFunction) => {
    const refreshToken = req.cookies?.refreshToken;

    if (refreshToken) {
      await authService.logout(refreshToken);
    }

    clearAuthCookies(res);

    res.status(200).json({
      status: "success",
      message: "Logged out successfully",
    });
  }
);

/**
 * GET /auth/me
 */
export const me = catchAsync(
  async (req: Request, res: Response, next: NextFunction) => {
    if (!req.user) {
      throw AppError.unauthorized("Not authenticated");
    }

    res.status(200).json({
      status: "success",
      data: {
        id: req.user._id,
        email: req.user.email,
        role: req.user.role,
        name: req.user.name,
        firstName: req.user.firstName,
        lastName: req.user.lastName,
        phone: req.user.phone,
        bio: req.user.bio,
        specializations: req.user.specializations,
        profileImage: req.user.profileImage,
        createdAt: req.user.createdAt,
        lastLogin: req.user.lastLogin,
      },
    });
  }
);

/**
 * PATCH /auth/update-password
 */
export const updatePassword = catchAsync(
  async (req: Request, res: Response, next: NextFunction) => {
    if (!req.user) {
      throw AppError.unauthorized("Not authenticated");
    }

    const { currentPassword, newPassword } = req.body;

    const { accessToken, refreshToken } = await authService.updatePassword(
      String(req.user._id),
      currentPassword,
      newPassword
    );

    // Set new cookies after password change
    setAccessTokenCookie(res, accessToken);
    setRefreshTokenCookie(res, refreshToken);

    res.status(200).json({
      status: "success",
      message: "Password updated successfully",
    });
  }
);

/**
 * POST /auth/forgot-password
 */
export const forgotPassword = catchAsync(
  async (req: Request, res: Response, next: NextFunction) => {
    const { email } = req.body;

    const resetToken = await authService.forgotPassword(email);

    // In production, send this via email instead of returning it
    if (env.NODE_ENV === "development" && resetToken) {
      res.status(200).json({
        status: "success",
        message: "Password reset token sent to email",
        resetToken, // REMOVE IN PRODUCTION
      });
    } else {
      res.status(200).json({
        status: "success",
        message: "If that email exists, a password reset link has been sent",
      });
    }
  }
);

/**
 * PATCH /auth/reset-password/:token
 */
export const resetPassword = catchAsync(
  async (req: Request, res: Response, next: NextFunction) => {
    const { token } = req.params;
    const { password } = req.body;

    await authService.resetPassword(token, password);

    res.status(200).json({
      status: "success",
      message:
        "Password reset successful. Please log in with your new password",
    });
  }
);


================================================================================
FILE: auth/src\controllers\authControllerOld.ts
================================================================================

// src/controllers/authController.ts
import { Request, Response, NextFunction } from "express";
import crypto from "crypto";
import User, { IUser } from "../models/userModel.js";
import catchAsync from "../utils/catchAsync.js";
import AppError from "../utils/appError.js";
import { signAccess, signRefresh } from "../utils/jwt.js";

interface AuthRequest extends Request {
  user?: IUser;
}

const createSendToken = (
  user: IUser,
  statusCode: number,
  res: Response
): void => {
  // JWT payload aligns with src/utils/jwt.ts (Claims: { sub, role? })
  const token = signAccess({
    sub: user._id.toString(),
    role: user.role,
    email: user.email,
  });

  const cookieDays = parseInt(process.env.JWT_COOKIE_EXPIRES_IN || "90", 10);
  const cookieOptions = {
    expires: new Date(Date.now() + cookieDays * 24 * 60 * 60 * 1000),
    httpOnly: true,
    secure: process.env.NODE_ENV === "production",
    sameSite: "lax" as const,
  };

  res.cookie("jwt", token, cookieOptions);

  // Hide password on the wire
  (user as any).password = undefined;

  res.status(statusCode).json({
    status: "success",
    token,
    data: { user },
  });
};

export const signup = catchAsync(async (req: Request, res: Response) => {
  const newUser = await User.create({
    firstName: req.body.firstName,
    lastName: req.body.lastName,
    email: req.body.email,
    phone: req.body.phone,
    role: req.body.role,
    password: req.body.password,
    passwordConfirm: req.body.passwordConfirm,
    specializations: req.body.specializations,
    bio: req.body.bio,
    hireDate: req.body.hireDate,
  });

  createSendToken(newUser, 201, res);
});

export const login = catchAsync(
  async (req: Request, res: Response, next: NextFunction) => {
    const { email, password } = req.body;

    if (!email || !password) {
      return next(new AppError("Please provide email and password!", 400));
    }

    const user = await User.findOne({ email }).select("+password");
    if (!user || !(await user.correctPassword(password, user.password))) {
      return next(new AppError("Incorrect email or password", 401));
    }

    user.lastLogin = new Date();
    await user.save({ validateBeforeSave: false });

    createSendToken(user, 200, res);
  }
);

export const logout = (_req: Request, res: Response): void => {
  res.cookie("jwt", "loggedout", {
    expires: new Date(Date.now() + 10 * 1000),
    httpOnly: true,
  });
  res.status(200).json({ status: "success" });
};

export const protect = catchAsync(
  async (req: AuthRequest, _res: Response, next: NextFunction) => {
    // 1) Get token
    let token: string | undefined;
    if (req.headers.authorization?.startsWith("Bearer ")) {
      token = req.headers.authorization.split(" ")[1];
    } else if ((req as any).cookies?.jwt) {
      token = (req as any).cookies.jwt;
    }

    if (!token) {
      return next(new AppError("You are not logged in!", 401));
    }

    // 2) Verify token
    const decoded = await signRefresh(token); // matches Claims: { sub, role?, iat, exp, ... }

    // 3) Check if user still exists
    const userId = decoded.payload.sub as string;
    const currentUser = await User.findById(userId);
    if (!currentUser) {
      return next(new AppError("The user no longer exists.", 401));
    }

    // 4) Check if user changed password after token was issued
    if (currentUser.changedPasswordAfter(decoded.payload.iat ?? 0)) {
      return next(
        new AppError(
          "User recently changed password! Please log in again.",
          401
        )
      );
    }

    req.user = currentUser;
    next();
  }
);

export const restrictTo = (...roles: string[]) => {
  return (req: AuthRequest, _res: Response, next: NextFunction) => {
    if (!req.user || !roles.includes(req.user.role)) {
      return next(
        new AppError("You do not have permission to perform this action", 403)
      );
    }
    next();
  };
};

export const forgotPassword = catchAsync(
  async (req: Request, res: Response, next: NextFunction) => {
    const user = await User.findOne({ email: req.body.email });
    if (!user) {
      return next(
        new AppError("There is no user with that email address.", 404)
      );
    }

    const resetToken = user.createPasswordResetToken();
    await user.save({ validateBeforeSave: false });

    try {
      res.status(200).json({
        status: "success",
        message: "Token sent to email!",
        resetToken, // TODO: send via email instead of returning in production
      });
    } catch {
      user.passwordResetToken = undefined;
      user.passwordResetExpires = undefined;
      await user.save({ validateBeforeSave: false });
      return next(
        new AppError(
          "There was an error sending the email. Try again later!",
          500
        )
      );
    }
  }
);

export const resetPassword = catchAsync(
  async (req: Request, res: Response, next: NextFunction) => {
    const hashedToken = crypto
      .createHash("sha256")
      .update(req.params.token)
      .digest("hex");

    const user = await User.findOne({
      passwordResetToken: hashedToken,
      passwordResetExpires: { $gt: Date.now() },
    });

    if (!user) {
      return next(new AppError("Token is invalid or has expired", 400));
    }

    user.password = req.body.password;
    user.passwordConfirm = req.body.passwordConfirm;
    user.passwordResetToken = undefined;
    user.passwordResetExpires = undefined;
    await user.save();

    createSendToken(user, 200, res);
  }
);

export const updatePassword = catchAsync(
  async (req: AuthRequest, res: Response, next: NextFunction) => {
    const user = await User.findById(req.user!.id).select("+password");
    if (!user) {
      return next(new AppError("User not found", 404));
    }

    const correct = await user.correctPassword(
      req.body.passwordCurrent,
      user.password
    );
    if (!correct) {
      return next(new AppError("Your current password is wrong.", 401));
    }

    user.password = req.body.password;
    user.passwordConfirm = req.body.passwordConfirm;
    await user.save();

    createSendToken(user, 200, res);
  }
);
export function refresh(arg0: string, refresh: any) {
  throw new Error("Function not implemented.");
}


================================================================================
FILE: auth/src\controllers\errorController.ts
================================================================================

import { Request, Response, NextFunction } from "express";
import AppError from "../utils/appError.js";
import { logger } from "../utils/logger.js";
import { env, isProduction } from "../config/env.js";

const handleCastErrorDB = (err: any): AppError => {
  const message = `Invalid ${err.path}: ${err.value}`;
  return AppError.badRequest(message);
};

const handleDuplicateFieldsDB = (err: any): AppError => {
  const field = Object.keys(err.keyValue || {})[0] || "field";
  const value = err.keyValue?.[field];
  const message = `Duplicate value for ${field}: ${value}. Please use another value`;
  return AppError.conflict(message);
};

const handleValidationErrorDB = (err: any): AppError => {
  const errors = Object.values(err.errors || {}).map((el: any) => el.message);
  const message = `Invalid input data. ${errors.join(". ")}`;
  return AppError.badRequest(message);
};

const handleJWTError = (): AppError =>
  AppError.unauthorized("Invalid token. Please log in again");

const handleJWTExpiredError = (): AppError =>
  AppError.unauthorized("Your token has expired. Please log in again");

const handleArgon2Error = (): AppError =>
  AppError.internal("Authentication error. Please try again");

const sendErrorDev = (err: AppError, req: Request, res: Response): void => {
  logger.error("Error:", {
    error: err,
    stack: err.stack,
    url: req.originalUrl,
    method: req.method,
    ip: req.ip,
  });

  res.status(err.statusCode).json({
    status: err.status,
    error: err,
    message: err.message,
    stack: err.stack,
  });
};

const sendErrorProd = (err: AppError, req: Request, res: Response): void => {
  // Operational, trusted error: send message to client
  if (err.isOperational) {
    res.status(err.statusCode).json({
      status: err.status,
      message: err.message,
    });
  }
  // Programming or unknown error: don't leak error details
  else {
    logger.error("Non-operational error:", {
      error: err,
      stack: err.stack,
      url: req.originalUrl,
      method: req.method,
      ip: req.ip,
    });

    res.status(500).json({
      status: "error",
      message: "Something went wrong. Please try again later",
    });
  }
};

export default (
  err: any,
  req: Request,
  res: Response,
  next: NextFunction
): void => {
  err.statusCode = err.statusCode || 500;
  err.status = err.status || "error";

  if (!isProduction) {
    sendErrorDev(err, req, res);
  } else {
    let error = Object.create(err);
    error.message = err.message;

    // Handle specific errors
    if (error.name === "CastError") error = handleCastErrorDB(error);
    if (error.code === 11000) error = handleDuplicateFieldsDB(error);
    if (error.name === "ValidationError")
      error = handleValidationErrorDB(error);
    if (error.name === "JsonWebTokenError") error = handleJWTError();
    if (error.name === "TokenExpiredError") error = handleJWTExpiredError();
    if (error.message?.includes("Argon2")) error = handleArgon2Error();

    sendErrorProd(error, req, res);
  }
};


================================================================================
FILE: auth/src\controllers\userController.ts
================================================================================

import { Request, Response, NextFunction } from "express";
import { userService } from "../services/userService.js";
import catchAsync from "../utils/catchAsync.js";
import AppError from "../utils/appError.js";

/**
 * GET /api/v1/users
 */
export const getAllUsers = catchAsync(
  async (req: Request, res: Response, next: NextFunction) => {
    const { role, active, search } = req.query;

    const filters = {
      role: role as string | undefined,
      active: active === "true" ? true : active === "false" ? false : undefined,
      search: search as string | undefined,
    };

    const users = await userService.getAllUsers(filters);

    res.status(200).json({
      status: "success",
      results: users.length,
      data: { users },
    });
  }
);

/**
 * GET /api/v1/users/stats
 */
export const getUserStats = catchAsync(
  async (req: Request, res: Response, next: NextFunction) => {
    const stats = await userService.getUserStats();

    res.status(200).json({
      status: "success",
      data: { stats },
    });
  }
);

/**
 * GET /api/v1/users/:id
 */
export const getUser = catchAsync(
  async (req: Request, res: Response, next: NextFunction) => {
    const user = await userService.getUser(req.params.id);

    res.status(200).json({
      status: "success",
      data: { user },
    });
  }
);

/**
 * GET /api/v1/users/me
 */
export const getMe = catchAsync(
  async (req: Request, res: Response, next: NextFunction) => {
    if (!req.user) {
      throw AppError.unauthorized("Not authenticated");
    }

    // Reuse getUser but with current user's ID
    req.params.id = String(req.user._id);
    return getUser(req, res, next);
  }
);

/**
 * PATCH /api/v1/users/me
 */
export const updateMe = catchAsync(
  async (req: Request, res: Response, next: NextFunction) => {
    if (!req.user) {
      throw AppError.unauthorized("Not authenticated");
    }

    // Prevent password updates through this route
    if (req.body.password || req.body.passwordConfirm) {
      throw AppError.badRequest(
        "This route is not for password updates. Use /auth/update-password"
      );
    }

    const user = await userService.updateUser(String(req.user._id), req.body);

    res.status(200).json({
      status: "success",
      data: { user },
    });
  }
);

/**
 * DELETE /api/v1/users/me
 */
export const deleteMe = catchAsync(
  async (req: Request, res: Response, next: NextFunction) => {
    if (!req.user) {
      throw AppError.unauthorized("Not authenticated");
    }

    await userService.deactivateUser(String(req.user._id));

    res.status(204).json({
      status: "success",
      data: null,
    });
  }
);

/**
 * PATCH /api/v1/users/:id (Admin only)
 */
export const updateUser = catchAsync(
  async (req: Request, res: Response, next: NextFunction) => {
    if (req.body.password || req.body.passwordConfirm) {
      throw AppError.badRequest("This route is not for password updates");
    }

    const user = await userService.updateUser(req.params.id, req.body);

    res.status(200).json({
      status: "success",
      data: { user },
    });
  }
);

/**
 * DELETE /api/v1/users/:id (Admin only)
 */
export const deleteUser = catchAsync(
  async (req: Request, res: Response, next: NextFunction) => {
    await userService.deactivateUser(req.params.id);

    res.status(204).json({
      status: "success",
      data: null,
    });
  }
);


================================================================================
FILE: auth/src\middleware\auth.ts
================================================================================

import { Request, Response, NextFunction } from "express";
import catchAsync from "../utils/catchAsync.js";
import AppError from "../utils/appError.js";
import * as jwtUtils from "../config/jwt.js";
import User from "../models/userModel.js";
import { JWTPayload } from "jose";
import { logger } from "../utils/logger.js";

export const protect = catchAsync(
  async (req: any, res: Response, next: NextFunction) => {
    // 1) get token from header or cookie
    const authHeader = req.get("authorization");
    const tokenFromHeader =
      authHeader && authHeader.startsWith("Bearer ")
        ? authHeader.split(" ")[1]
        : undefined;
    const tokenFromCookie = req.cookies?.jwt;

    const token = tokenFromHeader || tokenFromCookie;
    if (!token) {
      return next(
        AppError.unauthorized(
          "You are not logged in! Please log in to get access."
        )
      );
    }

    // 2) verify token using jwt.ts
    let verified;
    try {
      verified = await jwtUtils.verifyToken(token);
    } catch (err: any) {
      // Token invalid/expired
      return next(AppError.unauthorized("Invalid or expired token"));
    }

    const payload = verified.payload as JWTPayload;
    // payload.sub is the standard subject claim; your signToken should set sub to user id
    const userId = payload.sub as string | undefined;
    if (!userId) {
      return next(
        AppError.unauthorized("Token does not contain subject (sub)")
      );
    }

    // 3) ensure user still exists
    const user = await User.findById(userId).select("+role +email"); // adjust select as needed
    if (!user) {
      return next(
        AppError.unauthorized(
          "The user belonging to this token no longer exists."
        )
      );
    }

    // 4) attach minimal user info
    req.user = {
      id: user.id,
      email: user.email,
      role: user.role,
    };

    next();
  }
);

export const restrictTo = (...roles: string[]) => {
  return (req: Request, res: Response, next: NextFunction) => {
    if (!req.user) {
      return next(AppError.unauthorized("You are not logged in"));
    }

    if (!roles.includes(req.user.role)) {
      logger.warn(
        `Unauthorized access attempt by user ${req.user.id} with role ${req.user.role}`
      );
      return next(
        AppError.forbidden("You do not have permission to perform this action")
      );
    }

    next();
  };
};


================================================================================
FILE: auth/src\middleware\rateLimiter.ts
================================================================================

import rateLimit from "express-rate-limit";
import { isDevelopment } from "../config/env.js";

export const globalLimiter = rateLimit({
  max: 100,
  windowMs: 60 * 60 * 1000, // 1 hour
  message: "Too many requests from this IP, please try again later",
  standardHeaders: true,
  legacyHeaders: false,
  skip: () => isDevelopment, // Skip in development
});

export const authLimiter = rateLimit({
  max: 5,
  windowMs: 15 * 60 * 1000, // 15 minutes
  message: "Too many authentication attempts, please try again later",
  standardHeaders: true,
  legacyHeaders: false,
  skipSuccessfulRequests: true, // Don't count successful requests
});

export const passwordResetLimiter = rateLimit({
  max: 3,
  windowMs: 60 * 60 * 1000, // 1 hour
  message: "Too many password reset attempts, please try again later",
  standardHeaders: true,
  legacyHeaders: false,
});


================================================================================
FILE: auth/src\middleware\sanitize.ts
================================================================================

import { Request, Response, NextFunction } from "express";
import { logger } from "../utils/logger.js";
import AppError from "../utils/appError.js";

/**
 * Enhanced MongoDB sanitization middleware for Express 5.x
 * Detects and blocks NoSQL injection attempts
 */

const hasDangerousKeys = (obj: any, path: string = ""): string | null => {
  if (!obj || typeof obj !== "object") {
    return null;
  }

  if (Array.isArray(obj)) {
    for (let i = 0; i < obj.length; i++) {
      const result = hasDangerousKeys(obj[i], `${path}[${i}]`);
      if (result) return result;
    }
    return null;
  }

  for (const key in obj) {
    const fullPath = path ? `${path}.${key}` : key;

    // Check for MongoDB operators
    if (key.startsWith("$")) {
      return fullPath;
    }

    // Check for dots in keys (prototype pollution)
    if (key.includes(".")) {
      return fullPath;
    }

    // Check for __proto__ or constructor
    if (key === "__proto__" || key === "constructor" || key === "prototype") {
      return fullPath;
    }

    // Recursively check nested objects
    const result = hasDangerousKeys(obj[key], fullPath);
    if (result) return result;
  }

  return null;
};

export const mongoSanitize = (
  options: {
    onSanitize?: "remove" | "error";
    logAttempts?: boolean;
  } = {}
) => {
  const { onSanitize = "error", logAttempts = true } = options;

  return (req: Request, _res: Response, next: NextFunction) => {
    try {
      // Check body
      if (req.body) {
        const dangerousKey = hasDangerousKeys(req.body, "body");
        if (dangerousKey) {
          if (logAttempts) {
            logger.warn("NoSQL injection attempt detected", {
              ip: req.ip,
              path: req.path,
              key: dangerousKey,
              body: req.body,
            });
          }

          if (onSanitize === "error") {
            return next(
              AppError.badRequest(
                `Invalid request: dangerous key detected (${dangerousKey})`
              )
            );
          }
        }
      }

      // Check params
      if (req.params) {
        const dangerousKey = hasDangerousKeys(req.params, "params");
        if (dangerousKey) {
          if (logAttempts) {
            logger.warn("NoSQL injection attempt in params", {
              ip: req.ip,
              path: req.path,
              key: dangerousKey,
            });
          }

          if (onSanitize === "error") {
            return next(
              AppError.badRequest(
                `Invalid request: dangerous parameter (${dangerousKey})`
              )
            );
          }
        }
      }

      // Check query
      if (req.query) {
        const dangerousKey = hasDangerousKeys(req.query, "query");
        if (dangerousKey) {
          if (logAttempts) {
            logger.warn("NoSQL injection attempt in query", {
              ip: req.ip,
              path: req.path,
              key: dangerousKey,
            });
          }

          if (onSanitize === "error") {
            return next(
              AppError.badRequest(
                `Invalid request: dangerous query parameter (${dangerousKey})`
              )
            );
          }
        }
      }

      next();
    } catch (error) {
      next(error);
    }
  };
};


================================================================================
FILE: auth/src\middleware\validate.ts
================================================================================

import { Request, Response, NextFunction } from "express";
import { ZodSchema, ZodError } from "zod";
import AppError from "../utils/appError.js";

export const validate = (schema: ZodSchema) => {
  return (req: Request, res: Response, next: NextFunction) => {
    try {
      schema.parse({
        body: req.body,
        query: req.query,
        params: req.params,
      });
      next();
    } catch (error) {
      if (error instanceof ZodError) {
        const messages = error.issues.map((err) => ({
          field: err.path.join("."),
          message: err.message,
        }));

        return next(
          new AppError(
            `Validation error: ${messages.map((m) => m.message).join(", ")}`,
            400
          )
        );
      }
      next(error);
    }
  };
};


================================================================================
FILE: auth/src\models\sessionModel.ts
================================================================================

import mongoose, { Schema, Document } from "mongoose";
import crypto from "crypto";

export interface ISession extends Document {
  user: mongoose.Types.ObjectId;
  jti: string;
  tokenHash: string;
  createdAt: Date;
  expiresAt: Date;
  replacedBy?: string | null;
  revokedAt?: Date | null;
  ip?: string;
  ua?: string;
}

const SessionSchema = new Schema<ISession>(
  {
    user: {
      type: Schema.Types.ObjectId,
      ref: "User",
      required: true,
      index: true,
    },
    jti: {
      type: String,
      required: true,
      unique: true,
      index: true,
    },
    tokenHash: {
      type: String,
      required: true,
    },
    createdAt: {
      type: Date,
      default: () => new Date(),
      index: true,
    },
    expiresAt: {
      type: Date,
      required: true,
      index: true,
    },
    replacedBy: {
      type: String,
      default: null,
    },
    revokedAt: {
      type: Date,
      default: null,
      index: true,
    },
    ip: String,
    ua: String,
  },
  {
    timestamps: false, // We manually handle createdAt
  }
);

// Compound indexes for efficient queries
SessionSchema.index({ user: 1, revokedAt: 1 });
SessionSchema.index({ jti: 1, revokedAt: 1 });

// TTL index - MongoDB automatically deletes documents after expiration
SessionSchema.index({ expiresAt: 1 }, { expireAfterSeconds: 0 });

export function hashToken(token: string): string {
  return crypto.createHash("sha256").update(token).digest("hex");
}

export default mongoose.model<ISession>("Session", SessionSchema);


================================================================================
FILE: auth/src\models\userModel.ts
================================================================================

import mongoose, { Document, Types, Schema, Model } from "mongoose";
import validator from "validator";

export interface IUser extends Document {
  _id: Types.ObjectId;
  firstName?: string;
  lastName?: string;
  name?: string;
  email: string;
  phone?: string;
  role: "owner" | "admin" | "manager" | "therapist" | "receptionist";
  password: string;
  passwordChangedAt?: Date;
  passwordResetToken?: string;
  passwordResetExpires?: Date;
  active: boolean;
  profileImage?: string;
  specializations?: string[];
  bio?: string;
  hireDate?: Date;
  createdAt: Date;
  updatedAt: Date;
  lastLogin?: Date;
}

const userSchema = new Schema<IUser>(
  {
    firstName: {
      type: String,
      trim: true,
      maxlength: [50, "First name cannot exceed 50 characters"],
    },
    lastName: {
      type: String,
      trim: true,
      maxlength: [50, "Last name cannot exceed 50 characters"],
    },
    name: {
      type: String,
      trim: true,
      maxlength: [100, "Name cannot exceed 100 characters"],
    },
    email: {
      type: String,
      required: [true, "Email is required"],
      unique: true,
      lowercase: true,
      trim: true,
      validate: [validator.isEmail, "Please provide a valid email"],
      index: true,
    },
    phone: {
      type: String,
      trim: true,
      validate: {
        validator: function (v: string) {
          return !v || /^\+?[1-9]\d{1,14}$/.test(v);
        },
        message: "Please provide a valid phone number",
      },
    },
    role: {
      type: String,
      enum: {
        values: ["owner", "admin", "manager", "therapist", "receptionist"],
        message: "Role must be admin, manager, therapist, or receptionist",
      },
      default: "therapist",
      index: true,
    },
    password: {
      type: String,
      required: [true, "Password is required"],
      minlength: [8, "Password must be at least 8 characters"],
      select: false, // Don't return password by default
    },
    passwordChangedAt: {
      type: Date,
      select: false,
    },
    passwordResetToken: {
      type: String,
      select: false,
    },
    passwordResetExpires: {
      type: Date,
      select: false,
    },
    active: {
      type: Boolean,
      default: true,
      select: false,
    },
    profileImage: {
      type: String,
      validate: {
        validator: function (v: string) {
          return !v || validator.isURL(v);
        },
        message: "Please provide a valid URL for profile image",
      },
    },
    specializations: {
      type: [String],
      default: [],
    },
    bio: {
      type: String,
      maxlength: [500, "Bio cannot exceed 500 characters"],
    },
    hireDate: {
      type: Date,
    },
    lastLogin: {
      type: Date,
    },
  },
  {
    timestamps: true, // Adds createdAt and updatedAt
    toJSON: {
      virtuals: true,
      transform: function (doc, ret: { password?: string; __v?: any }) {
        delete ret.password;
        delete ret.__v;
        return ret;
      },
    },
    toObject: {
      virtuals: true,
      transform: function (doc, ret: { password?: string; __v?: any }) {
        delete ret.password;
        delete ret.__v;
        return ret;
      },
    },
  }
);

// Virtual for full name
userSchema.virtual("fullName").get(function (this: IUser) {
  if (this.firstName && this.lastName) {
    return `${this.firstName} ${this.lastName}`;
  }
  return this.name || this.email;
});

// Indexes
userSchema.index({ email: 1 });
userSchema.index({ role: 1 });
userSchema.index({ active: 1 });
userSchema.index({ createdAt: -1 });

// Query middleware - don't return inactive users by default
userSchema.pre(/^find/, function (next) {
  // Only filter if not explicitly querying for inactive users
  if (!(this as any).getOptions().includeInactive) {
    (this as any).find({ active: { $ne: false } });
  }
  next();
});

const User: Model<IUser> = mongoose.model<IUser>("User", userSchema);

export default User;


================================================================================
FILE: auth/src\routes\authRoutes.ts
================================================================================

import express from "express";
import * as authController from "../controllers/authController.js";
import { protect } from "../middleware/auth.js";
import { validate } from "../middleware/validate.js";
import {
  authLimiter,
  passwordResetLimiter,
} from "../middleware/rateLimiter.js";
import {
  signupSchema,
  loginSchema,
  updatePasswordSchema,
  forgotPasswordSchema,
  resetPasswordSchema,
} from "../utils/validators.js";

const router = express.Router();

// Public routes
router.post(
  "/signup",
  authLimiter,
  validate(signupSchema),
  authController.signup
);

router.post("/login", authLimiter, validate(loginSchema), authController.login);

router.post("/refresh", authController.refresh);

router.post("/logout", authController.logout);

router.post(
  "/forgot-password",
  passwordResetLimiter,
  validate(forgotPasswordSchema),
  authController.forgotPassword
);

router.patch(
  "/reset-password/:token",
  validate(resetPasswordSchema),
  authController.resetPassword
);

// Protected routes
router.use(protect);
router.get("/me", authController.me);

router.patch(
  "/update-password",
  validate(updatePasswordSchema),
  authController.updatePassword
);

export default router;


================================================================================
FILE: auth/src\routes\userRoutes.ts
================================================================================

import express from "express";
import * as userController from "../controllers/userController.js";
import { protect, restrictTo } from "../middleware/auth.js";
import { validate } from "../middleware/validate.js";
import { updateUserSchema } from "../utils/validators.js";

const router = express.Router();

// All routes require authentication
router.use(protect);

// Current user routes
router.get("/me", userController.getMe);
router.patch("/me", validate(updateUserSchema), userController.updateMe);
router.delete("/me", userController.deleteMe);

// Admin/Manager only routes
router.use(restrictTo("admin", "manager"));

router.get("/", userController.getAllUsers);
router.get("/stats", userController.getUserStats);

router
  .route("/:id")
  .get(userController.getUser)
  .patch(validate(updateUserSchema), userController.updateUser)
  .delete(userController.deleteUser);

export default router;


================================================================================
FILE: auth/src\services\authService.ts
================================================================================

import argon2 from "argon2";
import crypto from "crypto";
import User, { IUser } from "../models/userModel.js";
import { tokenService } from "./tokenService.js";
import AppError from "../utils/appError.js";
import { logger } from "../utils/logger.js";
import { SignupInput, LoginInput } from "../utils/validators.js";

export class AuthService {
  async signup(data: SignupInput): Promise<{
    user: IUser;
    accessToken: string;
    refreshToken: string;
  }> {
    // Check if user already exists
    const existingUser = await User.findOne({ email: data.email });
    if (existingUser) {
      throw AppError.conflict("Email already in use");
    }

    // Hash password with Argon2id
    const passwordHash = await argon2.hash(data.password, {
      type: argon2.argon2id,
      memoryCost: 65536, // 64 MiB
      timeCost: 3,
      parallelism: 4,
    });

    // Create user
    const user = await User.create({
      email: data.email,
      password: passwordHash,
      firstName: data.firstName,
      lastName: data.lastName,
      name: data.name,
      role: data.role || "therapist",
    });

    logger.info(`New user created: ${user.email}`);

    // Generate tokens
    const { accessToken, refreshToken } = await tokenService.generateTokenPair(
      user
    );

    return { user, accessToken, refreshToken };
  }

  async login(
    credentials: LoginInput,
    ip?: string,
    userAgent?: string
  ): Promise<{
    user: IUser;
    accessToken: string;
    refreshToken: string;
  }> {
    // Find user with password field
    const user = await User.findOne({ email: credentials.email })
      .select("+password +active")
      .exec();

    // DEBUG: Log everything
    console.log("=== LOGIN DEBUG ===");
    console.log("Email:", credentials.email);
    console.log("User found:", !!user);
    console.log("===================");

    if (!user) {
      throw AppError.unauthorized("Invalid email or password");
    }

    // Verify password
    const isValidPassword = await argon2.verify(
      user.password,
      credentials.password
    );

    console.log("=== PASSWORD VERIFICATION ===");
    console.log("Is valid:", isValidPassword);
    console.log("=============================");

    if (!isValidPassword) {
      logger.warn(`Failed login attempt for user: ${credentials.email}`);
      throw AppError.unauthorized("Invalid email or password");
    }

    // Check if user is active
    if (!user.active) {
      throw AppError.unauthorized("Your account has been deactivated");
    }

    // Update last login
    user.lastLogin = new Date();
    await user.save({ validateBeforeSave: false });

    logger.info(`User logged in: ${user.email}`);

    // Generate tokens
    const { accessToken, refreshToken } = await tokenService.generateTokenPair(
      user,
      ip,
      userAgent
    );

    return { user, accessToken, refreshToken };
  }

  async refreshTokens(
    refreshToken: string,
    ip?: string,
    userAgent?: string
  ): Promise<{ accessToken: string; refreshToken: string }> {
    // Validate refresh token
    const validation = await tokenService.validateRefreshToken(refreshToken);

    if (!validation.valid || !validation.userId) {
      throw AppError.unauthorized("Invalid or expired refresh token");
    }

    // Get user
    const user = await User.findById(validation.userId).select("+active");
    if (!user) {
      throw AppError.unauthorized("User no longer exists");
    }

    if (!user.active) {
      throw AppError.unauthorized("Your account has been deactivated");
    }

    // Revoke old token
    if (validation.jti) {
      await tokenService.revokeRefreshToken(validation.jti);
    }

    // Generate new token pair
    const tokens = await tokenService.generateTokenPair(user, ip, userAgent);

    logger.info(`Tokens refreshed for user: ${user.email}`);

    return tokens;
  }

  async logout(refreshToken: string): Promise<void> {
    try {
      const validation = await tokenService.validateRefreshToken(refreshToken);
      if (validation.valid && validation.jti) {
        await tokenService.revokeRefreshToken(validation.jti);
        logger.info(`User logged out, token revoked: ${validation.jti}`);
      }
    } catch (error) {
      logger.error("Logout error:", error);
      // Don't throw error on logout
    }
  }

  async updatePassword(
    userId: string,
    currentPassword: string,
    newPassword: string
  ): Promise<{ accessToken: string; refreshToken: string }> {
    // Get user with password
    const user = await User.findById(userId).select("+password");
    if (!user) {
      throw AppError.notFound("User not found");
    }

    // Verify current password
    const isValidPassword = await argon2.verify(user.password, currentPassword);

    if (!isValidPassword) {
      throw AppError.unauthorized("Current password is incorrect");
    }

    // Hash new password
    const passwordHash = await argon2.hash(newPassword, {
      type: argon2.argon2id,
      memoryCost: 65536,
      timeCost: 3,
      parallelism: 4,
    });

    // Update password
    user.password = passwordHash;
    user.passwordChangedAt = new Date();
    await user.save();

    logger.info(`Password updated for user: ${user.email}`);

    // Revoke all existing sessions
    await tokenService.revokeAllUserTokens(userId);

    // Generate new tokens
    const { accessToken, refreshToken } = await tokenService.generateTokenPair(
      user
    );

    return { accessToken, refreshToken };
  }

  async forgotPassword(email: string): Promise<string> {
    const user = await User.findOne({ email });
    if (!user) {
      // Don't reveal if user exists
      logger.warn(`Password reset requested for non-existent user: ${email}`);
      return ""; // Return empty token
    }

    // Generate reset token
    const resetToken = crypto.randomBytes(32).toString("hex");
    const hashedToken = crypto
      .createHash("sha256")
      .update(resetToken)
      .digest("hex");

    // Save to user
    user.passwordResetToken = hashedToken;
    user.passwordResetExpires = new Date(Date.now() + 10 * 60 * 1000); // 10 minutes
    await user.save({ validateBeforeSave: false });

    logger.info(`Password reset token generated for user: ${user.email}`);

    return resetToken; // Return unhashed token to send via email
  }

  async resetPassword(token: string, newPassword: string): Promise<void> {
    // Hash the token to compare with stored hash
    const hashedToken = crypto.createHash("sha256").update(token).digest("hex");

    // Find user with valid reset token
    const user = await User.findOne({
      passwordResetToken: hashedToken,
      passwordResetExpires: { $gt: Date.now() },
    });

    if (!user) {
      throw AppError.badRequest("Invalid or expired reset token");
    }

    // Hash new password
    const passwordHash = await argon2.hash(newPassword, {
      type: argon2.argon2id,
      memoryCost: 65536,
      timeCost: 3,
      parallelism: 4,
    });

    // Update password and clear reset token
    user.password = passwordHash;
    user.passwordChangedAt = new Date();
    user.passwordResetToken = undefined;
    user.passwordResetExpires = undefined;
    await user.save();

    logger.info(`Password reset completed for user: ${user.email}`);

    // Revoke all sessions
    await tokenService.revokeAllUserTokens(String(user._id));
  }
}

export const authService = new AuthService();


================================================================================
FILE: auth/src\services\tokenService.ts
================================================================================

import crypto from "crypto";
import { JWTPayload } from "jose";
import { signToken } from "../config/jwt.js";
import { env } from "../config/env.js";
import Session, { hashToken } from "../models/sessionModel.js";
import { IUser } from "../models/userModel.js";
import { logger } from "../utils/logger.js";

export class TokenService {
  async generateAccessToken(user: IUser): Promise<string> {
    const payload: JWTPayload = {
      sub: String(user._id),
      email: user.email,
      role: user.role,
    };

    return await signToken(payload, `${env.ACCESS_TOKEN_TTL_SEC}s`);
  }

  async generateRefreshToken(user: IUser): Promise<string> {
    const jti = crypto.randomBytes(32).toString("hex");
    const payload: JWTPayload = {
      sub: String(user._id),
      email: user.email,
      role: user.role,
      jti,
    };

    return await signToken(payload, `${env.REFRESH_TOKEN_TTL_SEC}s`);
  }

  async generateTokenPair(
    user: IUser,
    ip?: string,
    userAgent?: string
  ): Promise<{ accessToken: string; refreshToken: string }> {
    const [accessToken, refreshToken] = await Promise.all([
      this.generateAccessToken(user),
      this.generateRefreshToken(user),
    ]);

    // Store refresh token session
    const jti = this.extractJtiFromToken(refreshToken);
    await this.storeRefreshSession(user, jti, refreshToken, ip, userAgent);

    return { accessToken, refreshToken };
  }

  async storeRefreshSession(
    user: IUser,
    jti: string,
    refreshToken: string,
    ip?: string,
    userAgent?: string
  ): Promise<void> {
    const expiresAt = new Date(Date.now() + env.REFRESH_TOKEN_TTL_SEC * 1000);

    await Session.create({
      user: user._id,
      jti,
      tokenHash: hashToken(refreshToken),
      expiresAt,
      ip,
      ua: userAgent,
    });

    logger.info(`Refresh session created for user ${user._id}`);
  }

  async validateRefreshToken(
    refreshToken: string
  ): Promise<{ valid: boolean; jti?: string; userId?: string }> {
    try {
      const jti = this.extractJtiFromToken(refreshToken);
      const tokenHash = hashToken(refreshToken);

      const session = await Session.findOne({ jti });

      if (!session) {
        logger.warn(`Session not found for jti: ${jti}`);
        return { valid: false };
      }

      if (session.revokedAt) {
        logger.warn(`Revoked token used: ${jti}`);
        return { valid: false };
      }

      if (session.expiresAt < new Date()) {
        logger.warn(`Expired token used: ${jti}`);
        return { valid: false };
      }

      if (session.tokenHash !== tokenHash) {
        logger.warn(`Token hash mismatch for jti: ${jti}`);
        return { valid: false };
      }

      return { valid: true, jti, userId: String(session.user) };
    } catch (error) {
      logger.error("Token validation error:", error);
      return { valid: false };
    }
  }

  async revokeRefreshToken(jti: string): Promise<void> {
    await Session.updateOne({ jti }, { $set: { revokedAt: new Date() } });
    logger.info(`Refresh token revoked: ${jti}`);
  }

  async revokeAllUserTokens(userId: string): Promise<void> {
    await Session.updateMany(
      { user: userId, revokedAt: null },
      { $set: { revokedAt: new Date() } }
    );
    logger.info(`All tokens revoked for user: ${userId}`);
  }

  private extractJtiFromToken(token: string): string {
    // Decode JWT without verification (we'll verify separately)
    const parts = token.split(".");
    if (parts.length !== 3) {
      throw new Error("Invalid token format");
    }

    const payload = JSON.parse(Buffer.from(parts[1], "base64url").toString());

    if (!payload.jti) {
      throw new Error("Token missing jti claim");
    }

    return payload.jti;
  }

  async cleanupExpiredSessions(): Promise<void> {
    const result = await Session.deleteMany({
      expiresAt: { $lt: new Date() },
    });
    logger.info(`Cleaned up ${result.deletedCount} expired sessions`);
  }
}

export const tokenService = new TokenService();


================================================================================
FILE: auth/src\services\userService.ts
================================================================================

import User, { IUser } from "../models/userModel.js";
import AppError from "../utils/appError.js";
import { logger } from "../utils/logger.js";
import { UpdateUserInput } from "../utils/validators.js";

export class UserService {
  async getUser(userId: string): Promise<IUser> {
    const user = await User.findById(userId);

    if (!user) {
      throw AppError.notFound("User not found");
    }

    return user;
  }

  async getAllUsers(filters?: {
    role?: string;
    active?: boolean;
    search?: string;
  }): Promise<IUser[]> {
    const query: any = {};

    if (filters?.role) {
      query.role = filters.role;
    }

    if (filters?.active !== undefined) {
      query.active = filters.active;
    }

    if (filters?.search) {
      query.$or = [
        { email: { $regex: filters.search, $options: "i" } },
        { firstName: { $regex: filters.search, $options: "i" } },
        { lastName: { $regex: filters.search, $options: "i" } },
      ];
    }

    const users = await User.find(query).sort({ createdAt: -1 });
    return users;
  }

  async updateUser(userId: string, data: UpdateUserInput): Promise<IUser> {
    // Don't allow password updates through this method
    const updateData = { ...data };
    delete (updateData as any).password;
    delete (updateData as any).passwordConfirm;
    delete (updateData as any).role; // Only admins should change roles

    const user = await User.findByIdAndUpdate(userId, updateData, {
      new: true,
      runValidators: true,
    });

    if (!user) {
      throw AppError.notFound("User not found");
    }

    logger.info(`User updated: ${user.email}`);
    return user;
  }

  async deactivateUser(userId: string): Promise<void> {
    const user = await User.findByIdAndUpdate(
      userId,
      { active: false },
      { new: true }
    );

    if (!user) {
      throw AppError.notFound("User not found");
    }

    logger.info(`User deactivated: ${user.email}`);
  }

  async deleteUser(userId: string): Promise<void> {
    const user = await User.findByIdAndDelete(userId);

    if (!user) {
      throw AppError.notFound("User not found");
    }

    logger.info(`User permanently deleted: ${user.email}`);
  }

  async getUserStats(): Promise<{
    total: number;
    byRole: Record<string, number>;
    active: number;
    inactive: number;
  }> {
    const [total, byRole, active, inactive] = await Promise.all([
      User.countDocuments(),
      User.aggregate([{ $group: { _id: "$role", count: { $sum: 1 } } }]),
      User.countDocuments({ active: true }),
      User.countDocuments({ active: false }),
    ]);

    const roleStats: Record<string, number> = {};
    byRole.forEach((item) => {
      roleStats[item._id] = item.count;
    });

    return {
      total,
      byRole: roleStats,
      active,
      inactive,
    };
  }
}

export const userService = new UserService();


================================================================================
FILE: auth/src\types\express.d.ts
================================================================================

import { IUser } from "../models/userModel.js";

declare global {
  namespace Express {
    interface Request {
      user?: IUser;
      requestTime?: string;
    }
  }
}

export {};


================================================================================
FILE: auth/src\types\index.ts
================================================================================

export interface TokenPair {
  accessToken: string;
  refreshToken: string;
}

export interface AuthResponse {
  user: {
    id: string;
    email: string;
    role: string;
    name?: string;
    firstName?: string;
    lastName?: string;
  };
  accessToken: string;
  expiresIn: number;
}

export interface RefreshResponse {
  accessToken: string;
  expiresIn: number;
}

export interface ErrorResponse {
  status: "error" | "fail";
  message: string;
  errors?: Array<{
    field: string;
    message: string;
  }>;
}

export interface SuccessResponse<T = any> {
  status: "success";
  data?: T;
  message?: string;
}


================================================================================
FILE: auth/src\utils\appError.ts
================================================================================

export default class AppError extends Error {
  statusCode: number;
  status: string;
  isOperational: boolean;

  constructor(message: string, statusCode: number) {
    super(message);
    this.statusCode = statusCode;
    this.status = `${statusCode}`.startsWith("4") ? "fail" : "error";
    this.isOperational = true;

    Error.captureStackTrace(this, this.constructor);
  }

  static badRequest(message: string = "Bad request"): AppError {
    return new AppError(message, 400);
  }

  static unauthorized(message: string = "Unauthorized"): AppError {
    return new AppError(message, 401);
  }

  static forbidden(message: string = "Forbidden"): AppError {
    return new AppError(message, 403);
  }

  static notFound(message: string = "Not found"): AppError {
    return new AppError(message, 404);
  }

  static conflict(message: string = "Conflict"): AppError {
    return new AppError(message, 409);
  }

  static internal(message: string = "Internal server error"): AppError {
    return new AppError(message, 500);
  }
}


================================================================================
FILE: auth/src\utils\catchAsync.ts
================================================================================

import { Request, Response, NextFunction } from 'express';

export default (fn: Function) => {
  return (req: Request, res: Response, next: NextFunction) => {
    fn(req, res, next).catch(next);
  };
};

================================================================================
FILE: auth/src\utils\logger.ts
================================================================================

import winston from "winston";
import { env, isDevelopment } from "../config/env.js";

const logFormat = winston.format.combine(
  winston.format.timestamp({ format: "YYYY-MM-DD HH:mm:ss" }),
  winston.format.errors({ stack: true }),
  winston.format.splat(),
  winston.format.json()
);

const consoleFormat = winston.format.combine(
  winston.format.colorize(),
  winston.format.timestamp({ format: "YYYY-MM-DD HH:mm:ss" }),
  winston.format.printf(({ timestamp, level, message, ...meta }) => {
    let msg = `${timestamp} [${level}]: ${message}`;
    if (Object.keys(meta).length > 0) {
      msg += ` ${JSON.stringify(meta)}`;
    }
    return msg;
  })
);

export const logger = winston.createLogger({
  level: env.LOG_LEVEL,
  format: logFormat,
  defaultMeta: { service: "auth-service" },
  transports: [
    new winston.transports.File({
      filename: "logs/error.log",
      level: "error",
      maxsize: 5242880, // 5MB
      maxFiles: 5,
    }),
    new winston.transports.File({
      filename: "logs/combined.log",
      maxsize: 5242880,
      maxFiles: 5,
    }),
  ],
});

// Console logging for development
if (isDevelopment) {
  logger.add(
    new winston.transports.Console({
      format: consoleFormat,
    })
  );
}

// Create logs directory if it doesn't exist
import fs from "fs";
if (!fs.existsSync("logs")) {
  fs.mkdirSync("logs");
}


================================================================================
FILE: auth/src\utils\validators.ts
================================================================================

import { z } from "zod";

// Password validation rules
const passwordSchema = z
  .string()
  .min(8, "Password must be at least 8 characters")
  .max(128, "Password must be less than 128 characters")
  .regex(/[A-Z]/, "Password must contain at least one uppercase letter")
  .regex(/[a-z]/, "Password must contain at least one lowercase letter")
  .regex(/[0-9]/, "Password must contain at least one number")
  .regex(
    /[^A-Za-z0-9]/,
    "Password must contain at least one special character"
  );

// Auth schemas
export const signupSchema = z.object({
  body: z.object({
    email: z
      .string()
      .min(1, "Email is required")
      .email("Invalid email address")
      .toLowerCase()
      .trim(),
    password: passwordSchema,
    name: z.string().min(2).max(100).optional(),
    firstName: z.string().min(1).max(50).optional(),
    lastName: z.string().min(1).max(50).optional(),
    role: z
      .enum(["admin", "manager", "therapist", "receptionist"])
      .optional()
      .default("therapist"),
  }),
});

export const loginSchema = z.object({
  body: z.object({
    email: z
      .string()
      .min(1, "Email is required")
      .email("Invalid email address")
      .toLowerCase()
      .trim(),
    password: z.string().min(1, "Password is required"),
  }),
});

export const updatePasswordSchema = z
  .object({
    body: z.object({
      currentPassword: z.string().min(1, "Current password is required"),
      newPassword: passwordSchema,
      newPasswordConfirm: z
        .string()
        .min(1, "Password confirmation is required"),
    }),
  })
  .refine((data) => data.body.newPassword === data.body.newPasswordConfirm, {
    message: "Passwords do not match",
    path: ["body", "newPasswordConfirm"],
  });

export const updateUserSchema = z.object({
  body: z.object({
    firstName: z.string().min(1).max(50).optional(),
    lastName: z.string().min(1).max(50).optional(),
    email: z.string().email().toLowerCase().trim().optional(),
    phone: z
      .string()
      .regex(/^\+?[1-9]\d{1,14}$/)
      .optional(),
    bio: z.string().max(500).optional(),
    specializations: z.array(z.string()).optional(),
    profileImage: z.string().url().optional(),
  }),
});

export const forgotPasswordSchema = z.object({
  body: z.object({
    email: z
      .string()
      .min(1, "Email is required")
      .email("Invalid email address")
      .toLowerCase()
      .trim(),
  }),
});

export const resetPasswordSchema = z
  .object({
    body: z.object({
      password: passwordSchema,
      passwordConfirm: z.string().min(1, "Password confirmation is required"),
    }),
    params: z.object({
      token: z.string().min(1, "Reset token is required"),
    }),
  })
  .refine((data) => data.body.password === data.body.passwordConfirm, {
    message: "Passwords do not match",
    path: ["body", "passwordConfirm"],
  });

// Type exports
export type SignupInput = z.infer<typeof signupSchema>["body"];
export type LoginInput = z.infer<typeof loginSchema>["body"];
export type UpdatePasswordInput = z.infer<typeof updatePasswordSchema>["body"];
export type UpdateUserInput = z.infer<typeof updateUserSchema>["body"];
