Code combined from: C:\Users\p01mansoorg\Documents\python\Studio-S_manager\backend\src
================================================================================



================================================================================
FILE: backend/src\app.ts
================================================================================

import express, { Application, Request, Response, NextFunction } from "express";
import morgan from "morgan";
import helmet from "helmet";
import cors from "cors";
import AppError from "./utils/appError.js";
import globalErrorHandler from "./controllers/errorController.js";
import { extractUser } from "./middleware/userMiddleware.js";
import api from "./routes/index.js";
import { requestId } from "./middleware/requestId.js";
import verifyGateway from "./middleware/verifyGateway.js";

const app: Application = express();

// 1) GLOBAL MIDDLEWARES
app.use(helmet());

if (process.env.NODE_ENV === "development") {
  app.use(morgan("dev"));
}

app.use(express.json({ limit: "10kb" }));
app.use(express.urlencoded({ extended: true, limit: "10kb" }));

// CORS
app.use(cors({ origin: [/^http:\/\/localhost:\d+$/], credentials: true }));

app.use(requestId);

// Apply gateway check as broadly as possible (protect service)
app.use(verifyGateway);

// Extract user info from headers (set by API Gateway)
app.use(extractUser);

// 2) ROUTES
// Health check
app.get("/health", (req: Request, res: Response) => {
  res.status(200).json({ status: "healthy", service: "inventory-service" });
});

app.use("/api/v1", api);

// Handle undefined routes
app.all("*", (req: Request, res: Response, next: NextFunction) => {
  next(new AppError(`Can't find ${req.originalUrl} on this server!`, 404));
});

// Global error handler
app.use(globalErrorHandler);

export default app;


================================================================================
FILE: backend/src\server.ts
================================================================================

import http from "http";
import app from "./app";
import { env } from "./config/env";
import { testConnection, closePool } from "./config/database";
import { logger } from "./utils/logger.js";

const port = env.PORT;
let server: http.Server;

/**
 * Start the Express server
 */
const startServer = async () => {
  try {
    // Test database connection before starting server
    const dbConnected = await testConnection();

    if (!dbConnected) {
      logger.error("Failed to connect to database. Exiting...");
      process.exit(1);
    }

    // Start HTTP server
    server = app.listen(port, () => {
      logger.info(`üöÄ Backend Service running on port ${port}`);
      logger.info(`üìù Environment: ${env.NODE_ENV}`);
      logger.info(`üîó API: http://localhost:${port}/api/v1`);
      logger.info(`‚ù§Ô∏è  Health: http://localhost:${port}/health`);
    });
  } catch (error) {
    logger.error("Failed to start server:", error);
    process.exit(1);
  }
};

/**
 * Graceful shutdown handler
 */
const gracefulShutdown = async (signal: string) => {
  logger.info(`\n${signal} received. Starting graceful shutdown...`);

  if (server) {
    server.close(async () => {
      logger.info("‚úÖ HTTP server closed");

      try {
        await closePool();
        logger.info("‚úÖ Database connections closed");
        logger.info("üëã Graceful shutdown completed");
        process.exit(0);
      } catch (err) {
        logger.error("Error during shutdown:", err);
        process.exit(1);
      }
    });

    // Force close after 10 seconds
    setTimeout(() => {
      logger.error("‚ö†Ô∏è  Forcing shutdown after timeout");
      process.exit(1);
    }, 10000);
  } else {
    process.exit(0);
  }
};

// Handle process termination signals
process.on("SIGTERM", () => gracefulShutdown("SIGTERM"));
process.on("SIGINT", () => gracefulShutdown("SIGINT"));

// Handle unhandled promise rejections
process.on("unhandledRejection", (reason: Error, promise: Promise<any>) => {
  logger.error("üö® UNHANDLED REJECTION! Shutting down...");
  logger.error("Reason:", reason);
  logger.error("Promise:", promise);
  gracefulShutdown("UNHANDLED_REJECTION");
});

// Handle uncaught exceptions
process.on("uncaughtException", (err: Error) => {
  logger.error("üö® UNCAUGHT EXCEPTION! Shutting down...");
  logger.error("Error:", err.name, err.message);
  logger.error("Stack:", err.stack);
  process.exit(1);
});

// Start the server
startServer();


================================================================================
FILE: backend/src\config\database.ts
================================================================================

import { Pool, PoolConfig, QueryResultRow } from "pg";
import { env } from "./env";

// Database configuration
const config: PoolConfig = env.DATABASE_URL
  ? {
      connectionString: env.DATABASE_URL,
      max: 20, // Maximum number of clients in pool
      idleTimeoutMillis: 30000, // Close idle clients after 30 seconds
      connectionTimeoutMillis: 5000, // Return error after 5 seconds if connection not established
      ssl: env.DB_SSL === "true" ? { rejectUnauthorized: false } : false,
    }
  : {
      user: env.DB_USER,
      host: env.DB_HOST,
      database: env.DB_NAME,
      password: env.DB_PASSWORD,
      port: env.DB_PORT,
      max: 20,
      idleTimeoutMillis: 30000,
      connectionTimeoutMillis: 5000,
    };

// Create the connection pool
export const pool = new Pool(config);

// Handle pool errors
pool.on("error", (err, client) => {
  console.error("Unexpected error on idle client", err);
  // Don't exit the process, but log the error
});

// Handle pool connection events
pool.on("connect", () => {
  console.log("üìä New database client connected");
});

pool.on("remove", () => {
  console.log("üîå Database client removed from pool");
});

/**
 * Test database connection
 * @returns Promise<boolean> - true if connection successful
 */
export const testConnection = async (): Promise<boolean> => {
  try {
    const res = await pool.query("SELECT NOW() as now, version() as version");
    console.log("‚úÖ PostgreSQL connected successfully");
    console.log(`   Time: ${res.rows[0].now}`);
    console.log(`   Version: ${res.rows[0].version.split(",")[0]}`);
    return true;
  } catch (err) {
    console.error("‚ùå Database connection failed:", err);
    return false;
  }
};

/**
 * Execute a query with type safety
 * @param text - SQL query string
 * @param params - Query parameters
 * @returns Promise with typed result
 */
export const query = <T extends QueryResultRow = any>(
  text: string,
  params?: any[]
) => pool.query<T>(text, params);

/**
 * Get a client from the pool for transactions
 * @returns Promise with PoolClient
 */
export const getClient = () => pool.connect();

/**
 * Close all pool connections gracefully
 */
export const closePool = async (): Promise<void> => {
  try {
    await pool.end();
    console.log("üîí Database pool closed successfully");
  } catch (err) {
    console.error("Error closing database pool:", err);
    throw err;
  }
};


================================================================================
FILE: backend/src\config\env.ts
================================================================================

import { z } from "zod";
import dotenv from "dotenv";

// Load environment variables
dotenv.config();

const envSchema = z.object({
  // Node Environment
  NODE_ENV: z
    .enum(["development", "production", "test"])
    .default("development"),
  PORT: z.coerce.number().default(4001),

  // Gateway Secret for verifying requests
  GATEWAY_SECRET: z.string(),

  // Database Configuration
  DATABASE_URL: z.string().optional(),
  DB_USER: z.string().optional(),
  DB_HOST: z.string().optional(),
  DB_NAME: z.string().optional(),
  DB_PASSWORD: z.string().optional(),
  DB_PORT: z.coerce.number().optional().default(5432),
  DB_SSL: z.string().optional(),

  // CORS Configuration
  ALLOWED_ORIGINS: z.string().default("http://localhost:3000"),

  // Security
  RATE_LIMIT_MAX: z.coerce.number().default(100),
  RATE_LIMIT_WINDOW_MS: z.coerce.number().default(900000), // 15 minutes
});

// Parse and validate environment variables
const parsed = envSchema.safeParse(process.env);

if (!parsed.success) {
  console.error("‚ùå Invalid environment variables:");
  console.error(JSON.stringify(parsed.error.flatten().fieldErrors, null, 2));
  throw new Error("Invalid environment configuration");
}

// Export validated environment variables
export const env = parsed.data;

// Type-safe access to environment variables
export type Env = z.infer<typeof envSchema>;


================================================================================
FILE: backend/src\controllers\clientController.ts
================================================================================

import { Request, Response, NextFunction } from "express";
import { query } from "../config/database.js";
import AppError from "../utils/appError.js";
import catchAsync from "../utils/catchAsync.js";
import {
  createClientSchema,
  searchClientSchema,
} from "../validators/client.validator.js";

export const createClient = catchAsync(
  async (req: Request, res: Response, next: NextFunction) => {
    const validation = createClientSchema.safeParse(req);
    if (!validation.success) {
      return next(
        new AppError((validation.error as any).errors[0].message, 400)
      );
    }

    const { name, email, phone } = validation.data.body;

    // Split name into first and last name
    const nameParts = name.trim().split(/\s+/);
    const firstName = nameParts[0];
    const lastName = nameParts.slice(1).join(" ") || "."; // Default last name if missing

    const result = await query(
      `INSERT INTO clients (
        first_name, 
        last_name, 
        email, 
        phone, 
        whatsapp,
        created_at,
        updated_at
      ) VALUES ($1, $2, $3, $4, $5, NOW(), NOW()) RETURNING *`,
      [firstName, lastName, email || null, phone, phone] // Using phone as whatsapp by default
    );

    res.status(201).json({
      status: "success",
      data: {
        client: result.rows[0],
      },
    });
  }
);

export const searchClients = catchAsync(
  async (req: Request, res: Response, next: NextFunction) => {
    const validation = searchClientSchema.safeParse(req);
    if (!validation.success) {
      return next(new AppError("Invalid search parameters", 400));
    }

    const { q } = validation.data.query;

    if (!q) {
      return res.status(200).json({
        status: "success",
        data: {
          clients: [],
        },
      });
    }

    const searchTerm = `%${q}%`;

    const result = await query(
      `SELECT * FROM clients 
       WHERE 
         first_name ILIKE $1 OR 
         last_name ILIKE $1 OR 
         phone ILIKE $1 OR
         email ILIKE $1
       LIMIT 10`,
      [searchTerm]
    );

    // Map backend fields to frontend expected format if necessary
    // Frontend expects: id, name, email, phone
    const clients = result.rows.map((client: any) => ({
      id: client.id,
      name: `${client.first_name} ${client.last_name}`,
      email: client.email,
      phone: client.phone,
    }));

    res.status(200).json({
      status: "success",
      data: {
        clients,
      },
    });
  }
);


================================================================================
FILE: backend/src\controllers\errorController.ts
================================================================================

import { Request, Response, NextFunction } from "express";
import AppError from "../utils/appError";
import { logger } from "../utils/logger";
import { env } from "../config/env";

/**
 * Handle database-specific errors
 */
const handleDatabaseError = (err: any): AppError => {
  // Unique constraint violation
  if (err.code === "23505") {
    const match = err.detail?.match(/Key \((.*?)\)=\((.*?)\)/);
    const field = match ? match[1] : "field";
    const value = match ? match[2] : "value";
    const message = `Duplicate ${field}: ${value}. Please use another value.`;
    return new AppError(message, 409);
  }

  // Foreign key constraint violation
  if (err.code === "23503") {
    const message =
      "Invalid reference to related data. The referenced record does not exist.";
    return new AppError(message, 400);
  }

  // Invalid input syntax
  if (err.code === "22P02") {
    return new AppError("Invalid input data type provided", 400);
  }

  // Not null constraint violation
  if (err.code === "23502") {
    const column = err.column || "field";
    return new AppError(`Missing required field: ${column}`, 400);
  }

  // Check constraint violation
  if (err.code === "23514") {
    return new AppError("Data validation failed", 400);
  }

  return new AppError("Database operation failed", 500);
};

/**
 * Send detailed error in development
 */
const sendErrorDev = (err: AppError, req: Request, res: Response): void => {
  logger.error("ERROR üí•", {
    status: err.status,
    error: err,
    message: err.message,
    stack: err.stack,
    url: req.originalUrl,
    method: req.method,
  });

  res.status(err.statusCode).json({
    status: err.status,
    error: err,
    message: err.message,
    stack: err.stack,
    requestId: req.id,
  });
};

/**
 * Send limited error in production
 */
const sendErrorProd = (err: AppError, req: Request, res: Response): void => {
  // Operational, trusted error: send message to client
  if (err.isOperational) {
    res.status(err.statusCode).json({
      status: err.status,
      message: err.message,
      requestId: req.id,
    });
  } else {
    // Programming or other unknown error: don't leak error details
    logger.error("ERROR üí•", {
      error: err,
      url: req.originalUrl,
      method: req.method,
      requestId: req.id,
    });

    res.status(500).json({
      status: "error",
      message: "Something went wrong. Please try again later.",
      requestId: req.id,
    });
  }
};

/**
 * Global error handling middleware
 */
export default (
  err: any,
  req: Request,
  res: Response,
  next: NextFunction
): void => {
  err.statusCode = err.statusCode || 500;
  err.status = err.status || "error";

  if (env.NODE_ENV === "development") {
    sendErrorDev(err, req, res);
  } else {
    let error = { ...err };
    error.message = err.message;
    error.name = err.name;
    error.stack = err.stack;

    // Handle specific error types
    if (err.code) {
      error = handleDatabaseError(error);
    }

    // Handle JWT errors (if you add authentication later)
    if (error.name === "JsonWebTokenError") {
      error = new AppError("Invalid token. Please log in again.", 401);
    }

    if (error.name === "TokenExpiredError") {
      error = new AppError("Your token has expired. Please log in again.", 401);
    }

    // Handle validation errors
    if (error.name === "ValidationError") {
      const message = Object.values(error.errors || {})
        .map((e: any) => e.message)
        .join(". ");
      error = new AppError(message, 400);
    }

    sendErrorProd(error, req, res);
  }
};


================================================================================
FILE: backend/src\controllers\inventoryController.ts
================================================================================

import { Response, NextFunction } from "express";
import { pool, getClient } from "../config/database";
import catchAsync from "../utils/catchAsync";
import AppError from "../utils/appError";
import { UserRequest } from "../middleware/userMiddleware";
import { logger } from "../utils/logger";

/**
 * Get inventory levels with optional filtering
 * GET /api/v1/inventory/levels
 */
export const getInventoryLevels = catchAsync(
  async (req: UserRequest, res: Response, _next: NextFunction) => {
    const { location_id, product_id, low_stock, batch_number } = req.query;

    let queryText = `
      SELECT 
        il.*,
        p.name as product_name,
        p.sku,
        p.reorder_level,
        sl.name as location_name,
        sl.type as location_type,
        (il.quantity_available - il.quantity_reserved) as quantity_free
      FROM inventory_levels il
      JOIN products p ON il.product_id = p.id
      JOIN stock_locations sl ON il.location_id = sl.id
      WHERE 1=1
    `;

    const params: any[] = [];
    let paramCounter = 1;

    if (location_id) {
      queryText += ` AND il.location_id = $${paramCounter}`;
      params.push(location_id);
      paramCounter++;
    }

    if (product_id) {
      queryText += ` AND il.product_id = $${paramCounter}`;
      params.push(product_id);
      paramCounter++;
    }

    if (batch_number) {
      queryText += ` AND il.batch_number = $${paramCounter}`;
      params.push(batch_number);
      paramCounter++;
    }

    if (low_stock === "true") {
      queryText += ` AND il.quantity_available <= p.reorder_level`;
    }

    queryText += " ORDER BY p.name, sl.name";

    const result = await pool.query(queryText, params);

    logger.info(`Inventory levels retrieved: ${result.rows.length} items`);

    res.status(200).json({
      status: "success",
      results: result.rows.length,
      data: {
        inventoryLevels: result.rows,
      },
    });
  }
);

/**
 * Adjust inventory (add or remove)
 * POST /api/v1/inventory/adjust
 */
export const adjustInventory = catchAsync(
  async (req: UserRequest, res: Response, next: NextFunction) => {
    const {
      product_id,
      location_id,
      quantity_change,
      reason,
      batch_number,
      expiry_date,
    } = req.body;

    const client = await getClient();

    try {
      await client.query("BEGIN");

      // Check if inventory level exists
      const checkResult = await client.query(
        `SELECT * FROM inventory_levels 
         WHERE product_id = $1 AND location_id = $2 
         AND (batch_number = $3 OR ($3 IS NULL AND batch_number IS NULL))`,
        [product_id, location_id, batch_number]
      );

      let inventoryResult;

      if (checkResult.rows.length === 0) {
        // Create new inventory level
        if (quantity_change < 0) {
          throw new AppError(
            "Cannot reduce inventory that does not exist",
            400
          );
        }

        inventoryResult = await client.query(
          `INSERT INTO inventory_levels 
           (product_id, location_id, quantity_available, batch_number, expiry_date)
           VALUES ($1, $2, $3, $4, $5)
           RETURNING *`,
          [product_id, location_id, quantity_change, batch_number, expiry_date]
        );
      } else {
        // Update existing inventory level
        const currentQty = checkResult.rows[0].quantity_available;
        const newQty = currentQty + quantity_change;

        if (newQty < 0) {
          throw new AppError(
            "Insufficient inventory. Cannot reduce below zero.",
            400
          );
        }

        inventoryResult = await client.query(
          `UPDATE inventory_levels 
           SET quantity_available = $1, last_updated = CURRENT_TIMESTAMP
           WHERE id = $2
           RETURNING *`,
          [newQty, checkResult.rows[0].id]
        );
      }

      // Record the stock movement
      await client.query(
        `INSERT INTO stock_movements (
          product_id, to_location_id, quantity, movement_type, 
          reason, batch_number, performed_by
        ) VALUES ($1, $2, $3, $4, $5, $6, $7)`,
        [
          product_id,
          location_id,
          Math.abs(quantity_change),
          "adjustment",
          reason || "Manual adjustment",
          batch_number,
          req.user?.id,
        ]
      );

      await client.query("COMMIT");

      logger.info(
        `Inventory adjusted by user ${req.user?.id}: Product ${product_id}, Change: ${quantity_change}`
      );

      res.status(200).json({
        status: "success",
        data: {
          inventoryLevel: inventoryResult.rows[0],
        },
      });
    } catch (err) {
      await client.query("ROLLBACK");
      throw err;
    } finally {
      client.release();
    }
  }
);

/**
 * Transfer stock between locations
 * POST /api/v1/inventory/transfer
 */
export const transferStock = catchAsync(
  async (req: UserRequest, res: Response, next: NextFunction) => {
    const {
      product_id,
      from_location_id,
      to_location_id,
      quantity,
      reason,
      batch_number,
    } = req.body;

    const client = await getClient();

    try {
      await client.query("BEGIN");

      // Check source inventory
      const sourceResult = await client.query(
        `SELECT * FROM inventory_levels 
         WHERE product_id = $1 AND location_id = $2 
         AND (batch_number = $3 OR ($3 IS NULL AND batch_number IS NULL))`,
        [product_id, from_location_id, batch_number]
      );

      if (sourceResult.rows.length === 0) {
        throw new AppError("Product not found in source location", 404);
      }

      const sourceInventory = sourceResult.rows[0];
      const availableQty =
        sourceInventory.quantity_available - sourceInventory.quantity_reserved;

      if (availableQty < quantity) {
        throw new AppError(
          `Insufficient available quantity. Available: ${availableQty}, Requested: ${quantity}`,
          400
        );
      }

      // Reduce from source
      await client.query(
        `UPDATE inventory_levels 
         SET quantity_available = quantity_available - $1, 
             last_updated = CURRENT_TIMESTAMP
         WHERE id = $2`,
        [quantity, sourceInventory.id]
      );

      // Add to destination
      const destResult = await client.query(
        `SELECT * FROM inventory_levels 
         WHERE product_id = $1 AND location_id = $2 
         AND (batch_number = $3 OR ($3 IS NULL AND batch_number IS NULL))`,
        [product_id, to_location_id, batch_number]
      );

      if (destResult.rows.length === 0) {
        // Create new inventory level at destination
        await client.query(
          `INSERT INTO inventory_levels 
           (product_id, location_id, quantity_available, batch_number, expiry_date)
           VALUES ($1, $2, $3, $4, $5)`,
          [
            product_id,
            to_location_id,
            quantity,
            batch_number,
            sourceInventory.expiry_date,
          ]
        );
      } else {
        // Update existing inventory level at destination
        await client.query(
          `UPDATE inventory_levels 
           SET quantity_available = quantity_available + $1, 
               last_updated = CURRENT_TIMESTAMP
           WHERE id = $2`,
          [quantity, destResult.rows[0].id]
        );
      }

      // Record the stock movement
      await client.query(
        `INSERT INTO stock_movements (
          product_id, from_location_id, to_location_id, quantity, 
          movement_type, reason, batch_number, performed_by
        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8)`,
        [
          product_id,
          from_location_id,
          to_location_id,
          quantity,
          "transfer",
          reason || "Stock transfer",
          batch_number,
          req.user?.id,
        ]
      );

      await client.query("COMMIT");

      logger.info(
        `Stock transferred by user ${req.user?.id}: ${quantity} units of product ${product_id} from ${from_location_id} to ${to_location_id}`
      );

      res.status(200).json({
        status: "success",
        message: "Stock transferred successfully",
        data: {
          product_id,
          from_location_id,
          to_location_id,
          quantity,
        },
      });
    } catch (err) {
      await client.query("ROLLBACK");
      throw err;
    } finally {
      client.release();
    }
  }
);


================================================================================
FILE: backend/src\controllers\productController.ts
================================================================================

import { Response, NextFunction } from "express";
import { UserRequest } from "../middleware/userMiddleware";
import { productService } from "../services/product.service";
import catchAsync from "../utils/catchAsync";
import { logger } from "../utils/logger";

/**
 * Get all products with filtering and pagination
 * GET /api/v1/products
 */
export const getAllProducts = catchAsync(
  async (req: UserRequest, res: Response, next: NextFunction) => {
    const filters = {
      category_id: req.query.category_id as string,
      supplier_id: req.query.supplier_id as string,
      active:
        req.query.active === "true"
          ? true
          : req.query.active === "false"
          ? false
          : undefined,
      retail:
        req.query.retail === "true"
          ? true
          : req.query.retail === "false"
          ? false
          : undefined,
      search: req.query.search as string,
      page: req.query.page ? parseInt(req.query.page as string) : undefined,
      limit: req.query.limit ? parseInt(req.query.limit as string) : undefined,
      sort: req.query.sort as string,
    };

    const result = await productService.findAll(filters);

    logger.info(`Products retrieved: ${result.products.length} items`);

    res.status(200).json({
      status: "success",
      results: result.products.length,
      total: result.total,
      page: result.page,
      limit: result.limit,
      totalPages: result.totalPages,
      data: {
        products: result.products,
      },
    });
  }
);

/**
 * Get a single product by ID
 * GET /api/v1/products/:id
 */
export const getProduct = catchAsync(
  async (req: UserRequest, res: Response, next: NextFunction) => {
    const product = await productService.findById(req.params.id);

    logger.info(`Product retrieved: ${req.params.id}`);

    res.status(200).json({
      status: "success",
      data: {
        product,
      },
    });
  }
);

/**
 * Create a new product
 * POST /api/v1/products
 */
export const createProduct = catchAsync(
  async (req: UserRequest, res: Response, next: NextFunction) => {
    const product = await productService.create(req.body);

    logger.info(`Product created by user ${req.user?.id}: ${product.id}`);

    res.status(201).json({
      status: "success",
      data: {
        product,
      },
    });
  }
);

/**
 * Update a product
 * PATCH /api/v1/products/:id
 */
export const updateProduct = catchAsync(
  async (req: UserRequest, res: Response, next: NextFunction) => {
    const product = await productService.update(req.params.id, req.body);

    logger.info(`Product updated by user ${req.user?.id}: ${req.params.id}`);

    res.status(200).json({
      status: "success",
      data: {
        product,
      },
    });
  }
);

/**
 * Delete a product
 * DELETE /api/v1/products/:id
 */
export const deleteProduct = catchAsync(
  async (req: UserRequest, res: Response, next: NextFunction) => {
    await productService.delete(req.params.id);

    logger.info(`Product deleted by user ${req.user?.id}: ${req.params.id}`);

    res.status(204).json({
      status: "success",
      data: null,
    });
  }
);


================================================================================
FILE: backend/src\controllers\salesController.ts
================================================================================

import { Request, Response, NextFunction } from "express";
import { getClient } from "../config/database";
import AppError from "../utils/appError";
import catchAsync from "../utils/catchAsync";
import { createSaleSchema } from "../validators/sale.validator";

export const createSale = catchAsync(
  async (req: Request, res: Response, next: NextFunction) => {
    // 1. Validate Input
    const validation = createSaleSchema.safeParse(req);
    if (!validation.success) {
      return next(
        new AppError((validation.error as any).errors[0].message, 400)
      );
    }

    const {
      clientId,
      items,
      discount,
      payments,
      tips,
      loyaltyPointsRedeemed,
      clientName,
    } = validation.data.body;

    const client = await getClient();

    try {
      await client.query("BEGIN");

      // 2. Calculate Totals
      let subtotal = 0;
      items.forEach((item) => {
        subtotal += item.price * item.quantity;
      });

      let discountAmount = 0;
      if (discount.type === "percentage") {
        discountAmount = (subtotal * discount.value) / 100;
      } else {
        discountAmount = discount.value;
      }

      // Ensure discount doesn't exceed subtotal
      discountAmount = Math.min(discountAmount, subtotal);

      const afterDiscount = subtotal - discountAmount;
      const taxAmount = afterDiscount * 0.15; // 15% Tax Hardcoded for now

      let tipsTotal = 0;
      if (tips) {
        Object.values(tips).forEach((tip) => {
          tipsTotal += tip;
        });
      }

      const finalAmount = afterDiscount + taxAmount + tipsTotal;

      // 3. Insert Sale
      // If clientId is provided, use it. If not, we store NULL.
      // We currently don't have a way to store "Walk-in Client Name" in the sales table structure
      // except in the notes or by creating a temporary client.
      // For now, we'll append the clientName to notes if it's a walk-in.

      let notes = "";
      if (!clientId && clientName) {
        notes = `Walk-in Client: ${clientName}`;
      }

      const saleResult = await client.query(
        `INSERT INTO sales (
          client_id, 
          staff_id, 
          sale_date, 
          total_amount, 
          discount_amount, 
          tax_amount, 
          tips_total, 
          final_amount, 
          status, 
          receipt_number,
          notes
        ) VALUES ($1, $2, NOW(), $3, $4, $5, $6, $7, $8, $9, $10) RETURNING *`,
        [
          clientId || null,
          items[0].staffId || null, // Primary staff (fallback to first item's staff)
          subtotal,
          discountAmount,
          taxAmount,
          tipsTotal,
          finalAmount,
          "completed",
          `REC-${Date.now()}`, // Simple receipt number generation
          notes,
        ]
      );

      const sale = saleResult.rows[0];

      // 4. Insert Sale Items
      for (const item of items) {
        // Determine service_id vs product_id
        // If type is 'treatment' or 'appointment', we assume it maps to a service.
        // However, the frontend sends 'treatmentId' or 'appointmentId'.
        // We need to map these to 'service_id'.
        // For appointments, the appointment itself is NOT the service definition, but it links to one.
        // But here we are recording the SALE of the service.
        // Ideally we should have the serviceId in the cart item.
        // Assuming treatmentId IS the serviceId for treatments.

        const serviceId =
          item.type === "treatment" || item.type === "appointment"
            ? item.treatmentId || item.appointmentId
            : null;

        const productId = item.type === "product" ? item.productId : null;

        await client.query(
          `INSERT INTO sale_items (
            sale_id, 
            product_id, 
            service_id,
            quantity, 
            unit_price, 
            discount_amount, 
            subtotal, 
            staff_id, 
            staff_name
          ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)`,
          [
            sale.id,
            productId,
            serviceId,
            item.quantity,
            item.price,
            item.discount || 0,
            item.price * item.quantity,
            item.staffId || null,
            item.staffName || null,
          ]
        );

        // 5. Update Inventory (only for products)
        if (item.type === "product" && productId) {
          await client.query(
            `UPDATE inventory_levels 
              SET quantity_available = quantity_available - $1 
              WHERE product_id = $2`,
            [item.quantity, productId]
          );
        }
      }

      // 6. Insert Payments
      for (const payment of payments) {
        await client.query(
          `INSERT INTO payments (sale_id, method, amount) VALUES ($1, $2, $3)`,
          [sale.id, payment.method, payment.amount]
        );
      }

      await client.query("COMMIT");

      res.status(201).json({
        status: "success",
        data: {
          sale,
        },
      });
    } catch (error) {
      await client.query("ROLLBACK");
      next(error);
    } finally {
      client.release();
    }
  }
);


================================================================================
FILE: backend/src\controllers\treatmentController.ts
================================================================================

import { Request, Response, NextFunction } from "express";
import { pool } from "../config/database.js";
import catchAsync from "../utils/catchAsync.js";
import AppError from "../utils/appError.js";
import {
  createTreatmentSchema,
  updateTreatmentSchema,
} from "../validators/treatment.validator.js";
import { ZodError } from "zod";

// Helper to map DB row to API object
function mapRow(row: any) {
  return {
    id: row.id,
    name: row.name,
    description: row.description,
    durationMinutes: row.duration_minutes,
    price: Number(row.price),
    category: row.category,
    benefits: row.benefits || [],
    contraindications: row.contraindications || [],
    preparationInstructions: row.preparation_instructions,
    aftercareInstructions: row.aftercare_instructions,
    availableFor: row.available_for || [],
    imageUrl: row.image_url,
    isActive: row.is_active,
    popularityScore: row.popularity_score,
    tags: row.tags || [],
    createdAt: row.created_at,
    updatedAt: row.updated_at,
  };
}

// GET /api/v1/treatments
export const getAllTreatments = catchAsync(
  async (req: Request, res: Response) => {
    const q = `SELECT * FROM treatments ORDER BY created_at DESC`;
    const { rows } = await pool.query(q);
    res.status(200).json({
      status: "success",
      results: rows.length,
      data: { treatments: rows.map(mapRow) },
    });
  }
);

// GET /api/v1/treatments/:id
export const getTreatment = catchAsync(
  async (req: Request, res: Response, next: NextFunction) => {
    const q = `SELECT * FROM treatments WHERE id = $1 LIMIT 1`;
    const { rows } = await pool.query(q, [req.params.id]);
    if (rows.length === 0)
      return next(AppError.notFound("Treatment not found"));
    res
      .status(200)
      .json({ status: "success", data: { treatment: mapRow(rows[0]) } });
  }
);

// POST /api/v1/treatments
export const createTreatment = catchAsync(
  async (req: any, res: Response, next: NextFunction) => {
    try {
      createTreatmentSchema.parse({ body: req.body });
    } catch (err) {
      if (err instanceof ZodError)
        return next(
          AppError.badRequest(err.issues.map((i) => i.message).join(", "))
        );
      throw err;
    }

    const b = req.body;
    const q = `
    INSERT INTO treatments
      (name, description, duration_minutes, price, category,
       benefits, contraindications,
       preparation_instructions, aftercare_instructions,
       available_for, image_url, is_active, popularity_score, tags, created_at, updated_at)
    VALUES
      ($1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14, now(), now())
    RETURNING *;
  `;
    // store arrays as Postgres arrays or jsonb accordingly
    const params = [
      b.name,
      b.description || null,
      b.durationMinutes,
      b.price,
      b.category || null,
      b.benefits ? JSON.stringify(b.benefits) : null, // benefits -> JSONB
      b.contraindications ? JSON.stringify(b.contraindications) : null,
      b.preparationInstructions || null,
      b.aftercareInstructions || null,
      b.availableFor && b.availableFor.length ? b.availableFor : null, // TEXT[]
      b.imageUrl || null,
      typeof b.isActive === "boolean" ? b.isActive : true,
      b.popularityScore || 0,
      b.tags && b.tags.length ? b.tags : null, // TEXT[]
    ];

    const { rows } = await pool.query(q, params);
    res
      .status(201)
      .json({ status: "success", data: { treatment: mapRow(rows[0]) } });
  }
);

// PATCH /api/v1/treatments/:id
export const updateTreatment = catchAsync(
  async (req: any, res: Response, next: NextFunction) => {
    try {
      updateTreatmentSchema.parse({ body: req.body });
    } catch (err) {
      if (err instanceof ZodError)
        return next(
          AppError.badRequest(err.issues.map((i) => i.message).join(", "))
        );
      throw err;
    }

    // Build dynamic SET clause (safe parameterized)
    const fields = [];
    const values: any[] = [];
    let idx = 1;
    const b = req.body;
    const pushField = (col: string, val: any) => {
      fields.push(`${col} = $${idx++}`);
      values.push(val);
    };

    if (b.name !== undefined) pushField("name", b.name);
    if (b.description !== undefined) pushField("description", b.description);
    if (b.durationMinutes !== undefined)
      pushField("duration_minutes", b.durationMinutes);
    if (b.price !== undefined) pushField("price", b.price);
    if (b.category !== undefined) pushField("category", b.category);
    if (b.benefits !== undefined)
      pushField("benefits", b.benefits ? JSON.stringify(b.benefits) : null);
    if (b.contraindications !== undefined)
      pushField(
        "contraindications",
        b.contraindications ? JSON.stringify(b.contraindications) : null
      );
    if (b.preparationInstructions !== undefined)
      pushField("preparation_instructions", b.preparationInstructions);
    if (b.aftercareInstructions !== undefined)
      pushField("aftercare_instructions", b.aftercareInstructions);
    if (b.availableFor !== undefined)
      pushField(
        "available_for",
        b.availableFor && b.availableFor.length ? b.availableFor : null
      );
    if (b.imageUrl !== undefined) pushField("image_url", b.imageUrl);
    if (b.isActive !== undefined) pushField("is_active", b.isActive);
    if (b.popularityScore !== undefined)
      pushField("popularity_score", b.popularityScore);
    if (b.tags !== undefined)
      pushField("tags", b.tags && b.tags.length ? b.tags : null);

    if (fields.length === 0)
      return next(AppError.badRequest("No fields provided for update"));

    // add updated_at
    fields.push(`updated_at = now()`);

    const sql = `UPDATE treatments SET ${fields.join(
      ", "
    )} WHERE id = $${idx} RETURNING *`;
    values.push(req.params.id);

    const { rows } = await pool.query(sql, values);
    if (rows.length === 0)
      return next(AppError.notFound("Treatment not found"));
    res
      .status(200)
      .json({ status: "success", data: { treatment: mapRow(rows[0]) } });
  }
);

// DELETE /api/v1/treatments/:id
export const deleteTreatment = catchAsync(
  async (req: Request, res: Response, next: NextFunction) => {
    const q = `DELETE FROM treatments WHERE id = $1 RETURNING id`;
    const { rows } = await pool.query(q, [req.params.id]);
    if (rows.length === 0)
      return next(AppError.notFound("Treatment not found"));
    res.status(204).json({ status: "success", data: null });
  }
);


================================================================================
FILE: backend/src\middleware\requestId.ts
================================================================================

import { Request, Response, NextFunction } from "express";
import { randomUUID } from "crypto";

declare global {
  namespace Express {
    interface Request {
      id?: string;
    }
  }
}

/**
 * Middleware to add a unique request ID to each request
 * The ID is also added to response headers for tracing
 */
export const requestId = (
  req: Request,
  res: Response,
  next: NextFunction
): void => {
  // Use existing request ID from header or generate a new one
  const id = (req.headers["x-request-id"] as string) || randomUUID();

  req.id = id;
  res.setHeader("X-Request-Id", id);

  next();
};


================================================================================
FILE: backend/src\middleware\userMiddleware.ts
================================================================================

// src/middleware/userMiddleware.ts
import { Request, Response, NextFunction } from "express";
import AppError from "../utils/appError.js";
import { logger } from "../utils/logger.js";

/**
 * Ensure types across the repo can access req.user.
 * We still keep runtime defensive checks.
 */
export interface UserRequest extends Request {
  user?: { id?: string; role?: string; email?: string };
}

export const extractUser = (
  req: UserRequest,
  _res: Response,
  next: NextFunction
) => {
  try {
    const id = req.headers["x-user-id"]
      ? String(req.headers["x-user-id"])
      : undefined;
    const role = req.headers["x-user-role"]
      ? String(req.headers["x-user-role"])
      : undefined;
    const email = req.headers["x-user-email"]
      ? String(req.headers["x-user-email"])
      : undefined;
    if (id || role || email) {
      req.user = { id, role, email };
    } else {
      req.user = undefined;
    }
    next();
  } catch (err) {
    logger.error("Failed to extract user from headers", { err });
    next(AppError.internal("Failed to extract user"));
  }
};

export const restrictTo = (...roles: string[]) => {
  return (req: UserRequest, _res: Response, next: NextFunction) => {
    if (!req.user || !req.user.role) {
      return next(AppError.unauthorized("You are not logged in"));
    }
    if (!roles.includes(req.user.role)) {
      logger.warn("Permission denied", {
        required: roles,
        role: req.user.role,
        requestId: (req as any).id,
      });
      return next(AppError.forbidden("You do not have permission"));
    }
    next();
  };
};


================================================================================
FILE: backend/src\middleware\validation.ts
================================================================================

import { Request, Response, NextFunction } from "express";
import { ZodObject, ZodError } from "zod";
import AppError from "../utils/appError.js";
import { logger } from "../utils/logger.js";

/**
 * Express middleware factory. Pass a Zod object like:
 * const schema = z.object({ body: z.object({ name: z.string() }) });
 * router.post("/", validate(schema), controller);
 */
export const validate = (schema: ZodObject<any>) => {
  return async (req: Request, _res: Response, next: NextFunction) => {
    try {
      await schema.parseAsync({
        body: req.body,
        query: req.query,
        params: req.params,
      });
      return next();
    } catch (error) {
      if (error instanceof ZodError) {
        const errors = error.issues.map((iss) => ({
          field: iss.path.join("."),
          message: iss.message,
          code: iss.code,
        }));

        logger.warn(`Validation failed for ${req.method} ${req.path}`, {
          errors,
          requestId: (req as any).id,
        });
        return next(
          AppError.badRequest(
            "Validation failed: " + errors.map((e) => e.message).join(", ")
          )
        );
      }
      return next(error);
    }
  };
};

/** Validate a UUID route param named `paramName` (default 'id') */
export const validateUUID = (paramName = "id") => {
  return (req: Request, _res: Response, next: NextFunction) => {
    const uuid = req.params[paramName];
    const uuidRegex =
      /^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;

    if (!uuid || !uuidRegex.test(uuid)) {
      logger.warn(`Invalid UUID for param ${paramName}: ${uuid}`, {
        requestId: (req as any).id,
      });
      return next(
        AppError.badRequest(`Invalid ${paramName}. Must be a valid UUID.`)
      );
    }
    next();
  };
};

/* Optional helpers exported for other modules (tests/services) */
export const formatZodError = (err: ZodError) =>
  err.issues.map((iss) => ({
    field: iss.path.join("."),
    message: iss.message,
    code: iss.code,
  }));


================================================================================
FILE: backend/src\middleware\verifyGateway.ts
================================================================================

import { Request, Response, NextFunction } from "express";
import AppError from "../utils/appError.js";
import { logger } from "../utils/logger.js";
import { env } from "../config/env.js";

/**
 * Ensure requests to backend come from the API Gateway.
 * The gateway must include a shared secret header X-Gateway-Key.
 */
export default function verifyGateway(
  req: Request,
  _res: Response,
  next: NextFunction
) {
  const provided = String(req.headers["x-gateway-key"] || "");
  const secret = String(env.GATEWAY_SECRET);

  if (!secret) {
    logger.error(
      "GATEWAY_SECRET is not configured in env - refusing requests by default"
    );
    return next(AppError.internal("Server misconfiguration"));
  }

  if (!provided || provided !== secret) {
    logger.warn("Blocked request from non-gateway source", {
      path: req.path,
      ip: req.ip,
      requestId: (req as any).id,
    });
    return next(AppError.unauthorized("Request not from API Gateway"));
  }

  // Optionally attach trust-level flag
  (req as any).isFromGateway = true;
  next();
}


================================================================================
FILE: backend/src\routes\categoryRoutes.ts
================================================================================

import express from "express";
import { pool } from "../config/database.js";
import { z } from "zod";
import { restrictTo } from "../middleware/userMiddleware.js";

const router = express.Router();
const Create = z.object({
  name: z.string().min(1),
  parent_category_id: z.string().uuid().nullable().optional(),
});
const Update = Create.partial();

router.get("/", async (_req, res) => {
  const { rows } = await pool.query(
    `SELECT * FROM public.categories ORDER BY name ASC`
  );
  res.json({ items: rows });
});
router.post("/", restrictTo("owner", "manager"), async (req, res) => {
  const p = Create.parse(req.body);
  const { rows } = await pool.query(
    `INSERT INTO public.categories (name, parent_category_id) VALUES ($1,$2) RETURNING *`,
    [p.name, p.parent_category_id ?? null]
  );
  res.status(201).json(rows[0]);
});
router.patch("/:id", restrictTo("owner", "manager"), async (req, res) => {
  const p = Update.parse(req.body);
  const { rows } = await pool.query(
    `UPDATE public.categories SET name=COALESCE($1,name), parent_category_id=$2, updated_at=NOW() WHERE id=$3 RETURNING *`,
    [p.name ?? null, p.parent_category_id ?? null, req.params.id]
  );
  res.json(rows[0]);
});
router.delete("/:id", restrictTo("owner"), async (req, res) => {
  await pool.query(`DELETE FROM public.categories WHERE id=$1`, [
    req.params.id,
  ]);
  res.status(204).send();
});

export default router;


================================================================================
FILE: backend/src\routes\clientRoutes.ts
================================================================================

import { Router } from "express";
import {
  createClient,
  searchClients,
} from "../controllers/clientController.js";

const router = Router();

router.post("/", createClient);
router.get("/", searchClients);

export default router;


================================================================================
FILE: backend/src\routes\index.ts
================================================================================

import { Router } from "express";
import products from "./productRoutes.js";
import inventory from "./inventoryRoutes.js";
import categories from "./categoryRoutes.js";
import suppliers from "./supplierRoutes.js";
import locations from "./locationRoutes.js";
import sales from "./salesRoutes.js";
import clients from "./clientRoutes.js";
import treatmentRoutes from "./treatmentRoutes.js";

const r = Router();
r.use("/products", products);
r.use("/inventory", inventory);
r.use("/categories", categories);
r.use("/suppliers", suppliers);
r.use("/locations", locations);
r.use("/sales", sales);
r.use("/clients", clients);
r.use("/treatments", treatmentRoutes);
export default r;


================================================================================
FILE: backend/src\routes\inventoryRoutes.ts
================================================================================

import express from "express";
import * as inventoryController from "../controllers/inventoryController";
import { restrictTo } from "../middleware/userMiddleware";
import { validate } from "../middleware/validation";
import {
  adjustInventorySchema,
  transferStockSchema,
  inventoryLevelsQuerySchema,
} from "../validators/inventory.validator";

const router = express.Router();

router.get(
  "/levels",
  validate(inventoryLevelsQuerySchema),
  inventoryController.getInventoryLevels
);

router.post(
  "/adjust",
  restrictTo("owner", "manager", "admin"),
  validate(adjustInventorySchema),
  inventoryController.adjustInventory
);

router.post(
  "/transfer",
  restrictTo("owner", "manager", "admin"),
  validate(transferStockSchema),
  inventoryController.transferStock
);

export default router;


================================================================================
FILE: backend/src\routes\locationRoutes.ts
================================================================================

import express from "express";
import { pool } from "../config/database.js";
import { z } from "zod";
import { restrictTo } from "../middleware/userMiddleware.js";

const router = express.Router();
const Create = z.object({ code: z.string().min(1), name: z.string().min(1) });
const Update = Create.partial();

router.get("/", async (_req, res) => {
  const { rows } = await pool.query(
    `SELECT * FROM public.locations ORDER BY name ASC`
  );
  res.json({ items: rows });
});
router.post("/", restrictTo("owner", "manager"), async (req, res) => {
  const p = Create.parse(req.body);
  const { rows } = await pool.query(
    `INSERT INTO public.locations (code, name) VALUES ($1,$2) RETURNING *`,
    [p.code, p.name]
  );
  res.status(201).json(rows[0]);
});
router.patch("/:id", restrictTo("owner", "manager"), async (req, res) => {
  const p = Update.parse(req.body);
  const { rows } = await pool.query(
    `UPDATE public.locations SET code=COALESCE($1,code), name=COALESCE($2,name), updated_at=NOW() WHERE id=$3 RETURNING *`,
    [p.code ?? null, p.name ?? null, req.params.id]
  );
  res.json(rows[0]);
});
router.delete("/:id", restrictTo("owner"), async (req, res) => {
  await pool.query(`DELETE FROM public.locations WHERE id=$1`, [req.params.id]);
  res.status(204).send();
});

export default router;


================================================================================
FILE: backend/src\routes\productRoutes.ts
================================================================================

import express from "express";
import * as productController from "../controllers/productController";
import { restrictTo } from "../middleware/userMiddleware";
import { validate } from "../middleware/validation";
import {
  createProductSchema,
  updateProductSchema,
  getProductSchema,
  deleteProductSchema,
  productQuerySchema,
} from "../validators/product.validator";

const router = express.Router();

router
  .route("/")
  .get(validate(productQuerySchema), productController.getAllProducts)
  .post(
    restrictTo("owner", "manager", "admin"),
    validate(createProductSchema),
    productController.createProduct
  );

router
  .route("/:id")
  .get(validate(getProductSchema), productController.getProduct)
  .patch(
    restrictTo("owner", "manager", "admin"),
    validate(updateProductSchema),
    productController.updateProduct
  )
  .delete(
    restrictTo("owner", "admin"),
    validate(deleteProductSchema),
    productController.deleteProduct
  );

export default router;


================================================================================
FILE: backend/src\routes\salesRoutes.ts
================================================================================

import { Router } from "express";
import { createSale } from "../controllers/salesController.js";

const router = Router();

router.post("/", createSale);

export default router;


================================================================================
FILE: backend/src\routes\supplierRoutes.ts
================================================================================

import express from "express";
import { pool } from "../config/database.js";
import { z } from "zod";
import { restrictTo } from "../middleware/userMiddleware.js";

const router = express.Router();
const Create = z.object({
  name: z.string().min(1),
  email: z.string().email().optional(),
  phone: z.string().optional(),
});
const Update = Create.partial();

router.get("/", async (_req, res) => {
  const { rows } = await pool.query(
    `SELECT * FROM public.suppliers ORDER BY name ASC`
  );
  res.json({ items: rows });
});
router.post("/", restrictTo("owner", "manager"), async (req, res) => {
  const p = Create.parse(req.body);
  const { rows } = await pool.query(
    `INSERT INTO public.suppliers (name, email, phone) VALUES ($1,$2,$3) RETURNING *`,
    [p.name, p.email || null, p.phone || null]
  );
  res.status(201).json(rows[0]);
});
router.patch("/:id", restrictTo("owner", "manager"), async (req, res) => {
  const p = Update.parse(req.body);
  const { rows } = await pool.query(
    `UPDATE public.suppliers SET name=COALESCE($1,name), email=$2, phone=$3, updated_at=NOW() WHERE id=$4 RETURNING *`,
    [p.name ?? null, p.email ?? null, p.phone ?? null, req.params.id]
  );
  res.json(rows[0]);
});
router.delete("/:id", restrictTo("owner"), async (req, res) => {
  await pool.query(`DELETE FROM public.suppliers WHERE id=$1`, [req.params.id]);
  res.status(204).send();
});

export default router;


================================================================================
FILE: backend/src\routes\treatmentRoutes.ts
================================================================================

import { Router } from "express";
import * as treatmentController from "../controllers/treatmentController.js";
import { extractUser, restrictTo } from "../middleware/userMiddleware.js";
import { validate, validateUUID } from "../middleware/validation.js";
import {
  createTreatmentSchema,
  updateTreatmentSchema,
} from "../validators/treatment.validator.js";

const router = Router();

router.use(extractUser);

// list + read
router.get("/", treatmentController.getAllTreatments);
router.get("/:id", validateUUID("id"), treatmentController.getTreatment);

// create/update/delete with validation + RBAC
router.post(
  "/",
  validate(createTreatmentSchema),
  restrictTo("admin", "manager"),
  treatmentController.createTreatment
);
router.patch(
  "/:id",
  validateUUID("id"),
  validate(updateTreatmentSchema),
  restrictTo("admin", "manager"),
  treatmentController.updateTreatment
);
router.delete(
  "/:id",
  validateUUID("id"),
  restrictTo("admin"),
  treatmentController.deleteTreatment
);

export default router;


================================================================================
FILE: backend/src\services\inventory.service.ts
================================================================================



================================================================================
FILE: backend/src\services\product.service.ts
================================================================================

import { pool } from '../config/database';
import { Product } from '../types';
import AppError from '../utils/appError';
import { logger } from '../utils/logger';

export class ProductService {
  /**
   * Find all products with optional filtering
   */
  async findAll(filters: {
    category_id?: string;
    supplier_id?: string;
    active?: boolean;
    retail?: boolean;
    search?: string;
    page?: number;
    limit?: number;
    sort?: string;
  }) {
    try {
      const {
        category_id,
        supplier_id,
        active,
        retail,
        search,
        page = 1,
        limit = 50,
        sort = 'created_at',
      } = filters;

      const params: any[] = [];
      let paramIndex = 1;
      const conditions: string[] = [];

      // Build WHERE conditions
      if (category_id) {
        conditions.push(`p.category_id = $${paramIndex++}`);
        params.push(category_id);
      }

      if (supplier_id) {
        conditions.push(`p.supplier_id = $${paramIndex++}`);
        params.push(supplier_id);
      }

      if (active !== undefined) {
        conditions.push(`p.active = $${paramIndex++}`);
        params.push(active);
      }

      if (retail !== undefined) {
        conditions.push(`p.retail = $${paramIndex++}`);
        params.push(retail);
      }

      if (search) {
        conditions.push(
          `(p.name ILIKE $${paramIndex} OR p.sku ILIKE $${paramIndex})`
        );
        params.push(`%${search}%`);
        paramIndex++;
      }

      const whereClause = conditions.length > 0 ? `WHERE ${conditions.join(' AND ')}` : '';

      // Build ORDER BY clause
      const sortMap: Record<string, string> = {
        name: 'p.name',
        sku: 'p.sku',
        created_at: 'p.created_at',
        updated_at: 'p.updated_at',
        price_cents: 'p.price_cents',
        cost_cents: 'p.cost_cents',
      };

      const sortDirection = sort.startsWith('-') ? 'DESC' : 'ASC';
      const sortField = sort.replace(/^-/, '');
      const orderBy = sortMap[sortField] || 'p.created_at';

      // Pagination
      const offset = (page - 1) * limit;
      params.push(limit, offset);

      const query = `
        SELECT 
          p.*,
          c.name as category_name,
          s.name as supplier_name
        FROM products p
        LEFT JOIN categories c ON p.category_id = c.id
        LEFT JOIN suppliers s ON p.supplier_id = s.id
        ${whereClause}
        ORDER BY ${orderBy} ${sortDirection}
        LIMIT $${paramIndex} OFFSET $${paramIndex + 1}
      `;

      const [dataResult, countResult] = await Promise.all([
        pool.query(query, params),
        pool.query(`SELECT COUNT(*) FROM products p ${whereClause}`, params.slice(0, -2)),
      ]);

      return {
        products: dataResult.rows,
        total: parseInt(countResult.rows[0].count),
        page,
        limit,
        totalPages: Math.ceil(parseInt(countResult.rows[0].count) / limit),
      };
    } catch (error) {
      logger.error('Error in ProductService.findAll:', error);
      throw error;
    }
  }

  /**
   * Find a product by ID with inventory details
   */
  async findById(id: string) {
    try {
      const result = await pool.query(
        `SELECT 
          p.*,
          c.name as category_name,
          s.name as supplier_name,
          json_agg(
            json_build_object(
              'location_id', il.location_id,
              'location_name', sl.name,
              'quantity_available', il.quantity_available,
              'quantity_reserved', il.quantity_reserved,
              'quantity_free', (il.quantity_available - il.quantity_reserved),
              'batch_number', il.batch_number,
              'expiry_date', il.expiry_date
            )
          ) FILTER (WHERE il.id IS NOT NULL) as inventory_levels
        FROM products p
        LEFT JOIN categories c ON p.category_id = c.id
        LEFT JOIN suppliers s ON p.supplier_id = s.id
        LEFT JOIN inventory_levels il ON p.id = il.product_id
        LEFT JOIN stock_locations sl ON il.location_id = sl.id
        WHERE p.id = $1
        GROUP BY p.id, c.name, s.name`,
        [id]
      );

      if (result.rows.length === 0) {
        throw new AppError('Product not found', 404);
      }

      return result.rows[0];
    } catch (error) {
      logger.error('Error in ProductService.findById:', error);
      throw error;
    }
  }

  /**
   * Create a new product
   */
  async create(data: {
    sku: string;
    name: string;
    category_id?: string | null;
    supplier_id?: string | null;
    cost_cents: number;
    price_cents: number;
    retail?: boolean;
    active?: boolean;
  }) {
    try {
      const result = await pool.query(
        `INSERT INTO products 
        (sku, name, category_id, supplier_id, cost_cents, price_cents, retail, active)
        VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
        RETURNING *`,
        [
          data.sku,
          data.name,
          data.category_id ?? null,
          data.supplier_id ?? null,
          data.cost_cents,
          data.price_cents,
          data.retail ?? false,
          data.active ?? true,
        ]
      );

      logger.info(`Product created: ${result.rows[0].id}`);
      return result.rows[0];
    } catch (error: any) {
      if (error.code === '23505') {
        throw new AppError('A product with this SKU already exists', 409);
      }
      logger.error('Error in ProductService.create:', error);
      throw error;
    }
  }

  /**
   * Update a product
   */
  async update(id: string, data: Partial<Product>) {
    try {
      const fields: string[] = [];
      const values: any[] = [];
      let paramIndex = 1;

      // Build SET clause dynamically
      const updateFields: Array<{ key: keyof Product; dbColumn: string }> = [
        { key: 'sku', dbColumn: 'sku' },
        { key: 'name', dbColumn: 'name' },
        { key: 'category_id', dbColumn: 'category_id' },
        { key: 'supplier_id', dbColumn: 'supplier_id' },
        { key: 'cost_cents', dbColumn: 'cost_cents' },
        { key: 'price_cents', dbColumn: 'price_cents' },
        { key: 'retail', dbColumn: 'retail' },
        { key: 'active', dbColumn: 'active' },
      ];

      for (const { key, dbColumn } of updateFields) {
        if (data[key] !== undefined) {
          fields.push(`${dbColumn} = $${paramIndex++}`);
          values.push(data[key]);
        }
      }

      if (fields.length === 0) {
        throw new AppError('No fields to update', 400);
      }

      values.push(id);

      const result = await pool.query(
        `UPDATE products 
        SET ${fields.join(', ')}, updated_at = CURRENT_TIMESTAMP
        WHERE id = $${paramIndex}
        RETURNING *`,
        values
      );

      if (result.rows.length === 0) {
        throw new AppError('Product not found', 404);
      }

      logger.info(`Product updated: ${id}`);
      return result.rows[0];
    } catch (error) {
      logger.error('Error in ProductService.update:', error);
      throw error;
    }
  }

  /**
   * Delete a product
   */
  async delete(id: string) {
    try {
      const result = await pool.query(
        'DELETE FROM products WHERE id = $1 RETURNING id',
        [id]
      );

      if (result.rows.length === 0) {
        throw new AppError('Product not found', 404);
      }

      logger.info(`Product deleted: ${id}`);
      return true;
    } catch (error: any) {
      if (error.code === '23503') {
        throw new AppError(
          'Cannot delete product as it has associated inventory records',
          400
        );
      }
      logger.error('Error in ProductService.delete:', error);
      throw error;
    }
  }
}

export const productService = new ProductService();

================================================================================
FILE: backend/src\types\express.d.ts
================================================================================

import { Request } from "express";

declare global {
  namespace Express {
    interface Request {
      id?: string;
      user?: {
        id?: string;
        role?: string;
        email?: string;
      };
    }
  }
}

export {};


================================================================================
FILE: backend/src\types\index.ts
================================================================================

export interface Product {
  id: string;
  name: string;
  sku: string;
  category_id?: string;
  brand?: string;
  supplier_id?: string;
  description?: string;
  unit_of_measure?: string; // Made optional as it might not be in service
  cost_cents: number; // Changed from unit_cost
  price_cents: number; // Changed from retail_price
  retail: boolean; // Changed from retail_price (boolean flag?)
  active: boolean; // Changed from is_active
  reorder_level?: number;
  expiry_tracking?: boolean;
  created_at: Date;
  updated_at: Date;
}

export interface InventoryLevel {
  id: string;
  product_id: string;
  location_id: string;
  quantity_available: number;
  quantity_reserved: number;
  batch_number?: string;
  expiry_date?: Date;
  last_updated: Date;
}

export interface StockMovement {
  id: string;
  product_id: string;
  from_location_id?: string;
  to_location_id?: string;
  quantity: number;
  movement_type:
    | "transfer"
    | "adjustment"
    | "sale"
    | "usage"
    | "return"
    | "restock";
  reference_id?: string;
  reference_type?: string;
  reason?: string;
  performed_by?: string;
  batch_number?: string;
  cost_per_unit?: number;
  timestamp: Date;
}

export interface Sale {
  id: string;
  client_id?: string;
  staff_id: string;
  sale_date: Date;
  total_amount: number;
  discount_amount: number;
  tax_amount: number;
  tips_total: number;
  final_amount: number;
  status: "pending" | "completed" | "cancelled" | "refunded";
  payment_status?: string;
  loyalty_points_earned: number;
  receipt_number: string;
  notes?: string;
  created_at: Date;
  items?: SaleItem[];
  payments?: Payment[];
}

export interface SaleItem {
  id: string;
  sale_id: string;
  product_id?: string; // Made optional/nullable
  service_id?: string; // Added
  quantity: number;
  unit_price: number;
  discount_amount: number;
  subtotal: number;
  staff_id?: string;
  staff_name?: string;
  created_at: Date;
}

export interface Payment {
  id: string;
  sale_id: string;
  method: "cash" | "card" | "loyalty" | "gift-card";
  amount: number;
  reference?: string;
  created_at: Date;
}


================================================================================
FILE: backend/src\utils\apiFeatures.ts
================================================================================

export interface QueryString {
  page?: string;
  sort?: string;
  limit?: string;
  fields?: string;
  search?: string;
  [key: string]: any;
}

const DEFAULT_LIMIT = 50;

class APIFeatures {
  queryText: string;
  queryParams: any[];
  queryString: QueryString;
  whereConditions: string[];
  paramCounter: number;
  allowedSort: Record<string, string>; // map api‚Üísql column

  constructor(
    queryText: string,
    queryParams: any[],
    queryString: QueryString,
    allowedSort: Record<string, string>
  ) {
    this.queryText = queryText;
    this.queryParams = queryParams;
    this.queryString = queryString;
    this.whereConditions = [];
    this.paramCounter = queryParams.length + 1;
    this.allowedSort = allowedSort;
  }

  filter(): this {
    const queryObj = { ...this.queryString };
    const excludedFields = ["page", "sort", "limit", "fields", "search"];
    excludedFields.forEach((el) => delete queryObj[el]);

    Object.keys(queryObj).forEach((key) => {
      if (queryObj[key] !== undefined) {
        this.whereConditions.push(`${key} = $${this.paramCounter}`);
        this.queryParams.push(queryObj[key]);
        this.paramCounter++;
      }
    });

    return this;
  }

  search(fields: string[] = []): this {
    if (this.queryString.search && fields.length > 0) {
      const searchConditions = fields
        .map((field) => `${field} ILIKE $${this.paramCounter}`)
        .join(" OR ");

      this.whereConditions.push(`(${searchConditions})`);
      this.queryParams.push(`%${this.queryString.search}%`);
      this.paramCounter++;
    }
    return this;
  }

  buildWhereClause(): this {
    if (this.whereConditions.length > 0) {
      this.queryText += " WHERE " + this.whereConditions.join(" AND ");
    }
    return this;
  }

  sort(): this {
    if (this.queryString.sort) {
      const sortBy = this.queryString.sort
        .split(",")
        .map((field) => {
          if (field.startsWith("-")) {
            return `${field.substring(1)} DESC`;
          }
          return `${field} ASC`;
        })
        .join(", ");
      this.queryText += ` ORDER BY ${sortBy}`;
    } else {
      this.queryText += " ORDER BY created_at DESC";
    }
    return this;
  }

  paginate(): this {
    const page = parseInt(this.queryString.page || "1");
    const limit = parseInt(this.queryString.limit || "100");
    const offset = (page - 1) * limit;

    this.queryText += ` LIMIT $${this.paramCounter} OFFSET $${
      this.paramCounter + 1
    }`;
    this.queryParams.push(limit, offset);
    this.paramCounter += 2;

    return this;
  }
}

export default APIFeatures;


================================================================================
FILE: backend/src\utils\appError.ts
================================================================================

import { logger } from "./logger.js";

/**
 * AppError: central error class used across the app.
 * Always create AppError via AppError.badRequest(...), AppError.unauthorized(...), etc.
 */
class AppError extends Error {
  statusCode: number;
  status: string;
  isOperational: boolean;

  constructor(message: string, statusCode = 500) {
    super(message);

    this.statusCode = statusCode;
    this.status = `${statusCode}`.startsWith("4") ? "fail" : "error";
    this.isOperational = true;

    Error.captureStackTrace(this, this.constructor);

    // Log immediately with logger ‚Äì include stack & requestId if present in meta
    logger.error(message, {
      statusCode: this.statusCode,
      stack: this.stack,
    });
  }

  // Helpers
  static badRequest(msg = "Bad request") {
    return new AppError(msg, 400);
  }
  static unauthorized(msg = "Unauthorized") {
    return new AppError(msg, 401);
  }
  static forbidden(msg = "Forbidden") {
    return new AppError(msg, 403);
  }
  static notFound(msg = "Not found") {
    return new AppError(msg, 404);
  }
  static conflict(msg = "Conflict") {
    return new AppError(msg, 409);
  }
  static internal(msg = "Internal server error") {
    return new AppError(msg, 500);
  }

  toJSON() {
    return {
      status: this.status,
      statusCode: this.statusCode,
      message: this.message,
    };
  }
}

export default AppError;


================================================================================
FILE: backend/src\utils\catchAsync.ts
================================================================================

import { Request, Response, NextFunction } from 'express';

export default (fn: Function) => {
  return (req: Request, res: Response, next: NextFunction) => {
    Promise.resolve(fn(req, res, next)).catch(next);
  };
};

================================================================================
FILE: backend/src\utils\logger.ts
================================================================================

import winston from "winston";
import { env } from "../config/env";

// Define log levels
const levels = {
  error: 0,
  warn: 1,
  info: 2,
  http: 3,
  debug: 4,
};

// Determine log level based on environment
const level = () => {
  const isDevelopment = env.NODE_ENV === "development";
  return isDevelopment ? "debug" : "info";
};

// Define colors for each level
const colors = {
  error: "red",
  warn: "yellow",
  info: "green",
  http: "magenta",
  debug: "white",
};

// Tell winston about our colors
winston.addColors(colors);

// Define log format
const format = winston.format.combine(
  winston.format.timestamp({ format: "YYYY-MM-DD HH:mm:ss" }),
  winston.format.errors({ stack: true }),
  winston.format.splat(),
  winston.format.json()
);

// Define format for console output in development
const consoleFormat = winston.format.combine(
  winston.format.colorize({ all: true }),
  winston.format.timestamp({ format: "YYYY-MM-DD HH:mm:ss" }),
  winston.format.printf(
    (info) =>
      `${info.timestamp} [${info.level}]: ${info.message}${
        info.stack ? "\n" + info.stack : ""
      }`
  )
);

// Define transports
const transports = [
  // Console transport with colors for development
  new winston.transports.Console({
    format: env.NODE_ENV === "development" ? consoleFormat : format,
  }),

  // File transport for errors
  new winston.transports.File({
    filename: "logs/error.log",
    level: "error",
    maxsize: 5242880, // 5MB
    maxFiles: 5,
  }),

  // File transport for all logs
  new winston.transports.File({
    filename: "logs/combined.log",
    maxsize: 5242880, // 5MB
    maxFiles: 5,
  }),
];

// Create the logger
export const logger = winston.createLogger({
  level: level(),
  levels,
  format,
  transports,
  exitOnError: false,
});

// Create a stream object for Morgan HTTP logging
export const stream = {
  write: (message: string) => {
    logger.http(message.trim());
  },
};

// Export a child logger for specific modules
export const createModuleLogger = (moduleName: string) => {
  return logger.child({ module: moduleName });
};


================================================================================
FILE: backend/src\utils\validation.ts
================================================================================

import { z } from 'zod';
import { Request, Response, NextFunction } from 'express';


export function validate(schema: z.ZodTypeAny, path: 'body'|'params'|'query' = 'body') {
return (req: Request, res: Response, next: NextFunction) => {
const result = schema.safeParse((req as any)[path]);
if (!result.success) {
return res.status(400).json({ success: false, error: result.error.flatten() });
}
(req as any)[path] = result.data;
next();
};
}

================================================================================
FILE: backend/src\validators\client.validator.ts
================================================================================

import { z } from "zod";

export const createClientSchema = z.object({
  body: z.object({
    name: z.string().min(1, "Name is required"),
    email: z.string().email().optional().or(z.literal("")),
    phone: z.string().min(1, "Phone is required"),
  }),
});

export const searchClientSchema = z.object({
  query: z.object({
    q: z.string().optional(),
  }),
});


================================================================================
FILE: backend/src\validators\inventory.validator.ts
================================================================================

import { z } from "zod";

// Schema for adjusting inventory
export const adjustInventorySchema = z.object({
  body: z.object({
    product_id: z.string().uuid("Invalid product ID"),
    location_id: z.string().uuid("Invalid location ID"),
    quantity_change: z
      .number({ error: "Quantity change is required" })
      .int("Quantity change must be an integer")
      .refine((val) => val !== 0, {
        message: "Quantity change cannot be zero",
      }),
    reason: z
      .string()
      .max(500, "Reason must be less than 500 characters")
      .optional(),
    batch_number: z
      .string()
      .max(120, "Batch number must be less than 120 characters")
      .nullable()
      .optional(),
    expiry_date: z
      .string()
      .datetime({ message: "Invalid date format. Use ISO 8601 format" })
      .nullable()
      .optional(),
  }),
});

// Schema for transferring stock
export const transferStockSchema = z.object({
  body: z
    .object({
      product_id: z.string().uuid("Invalid product ID"),
      from_location_id: z.string().uuid("Invalid source location ID"),
      to_location_id: z.string().uuid("Invalid destination location ID"),
      quantity: z
        .number({ error: "Quantity is required" })
        .int("Quantity must be an integer")
        .positive("Quantity must be greater than zero"),
      reason: z
        .string()
        .max(500, "Reason must be less than 500 characters")
        .optional(),
      batch_number: z
        .string()
        .max(120, "Batch number must be less than 120 characters")
        .nullable()
        .optional(),
    })
    .refine((data) => data.from_location_id !== data.to_location_id, {
      message: "Source and destination locations must be different",
      path: ["to_location_id"],
    }),
});

// Schema for inventory levels query
export const inventoryLevelsQuerySchema = z.object({
  query: z.object({
    location_id: z.string().uuid("Invalid location ID").optional(),
    product_id: z.string().uuid("Invalid product ID").optional(),
    low_stock: z.enum(["true", "false"]).optional(),
    batch_number: z.string().optional(),
    page: z.coerce.number().int().positive().optional(),
    limit: z.coerce.number().int().positive().max(100).optional(),
  }),
});


================================================================================
FILE: backend/src\validators\product.validator.ts
================================================================================

import { z } from "zod";

// Base product schema for creation
export const createProductSchema = z.object({
  body: z.object({
    sku: z
      .string()
      .min(1, "SKU is required")
      .max(100, "SKU must be less than 100 characters")
      .trim(),
    name: z
      .string()
      .min(1, "Product name is required")
      .max(255, "Product name must be less than 255 characters")
      .trim(),
    category_id: z.string().uuid("Invalid category ID").nullable().optional(),
    supplier_id: z.string().uuid("Invalid supplier ID").nullable().optional(),
    cost_cents: z
      .number()
      .int("Cost must be an integer")
      .nonnegative("Cost cannot be negative"),
    price_cents: z
      .number()
      .int("Price must be an integer")
      .nonnegative("Price cannot be negative"),
    retail: z.boolean().default(false),
    active: z.boolean().default(true),
  }),
});

// Schema for updating a product (all fields optional)
export const updateProductSchema = z.object({
  params: z.object({
    id: z.string().uuid("Invalid product ID"),
  }),
  body: z.object({
    sku: z
      .string()
      .min(1, "SKU cannot be empty")
      .max(100, "SKU must be less than 100 characters")
      .trim()
      .optional(),
    name: z
      .string()
      .min(1, "Product name cannot be empty")
      .max(255, "Product name must be less than 255 characters")
      .trim()
      .optional(),
    category_id: z.string().uuid("Invalid category ID").nullable().optional(),
    supplier_id: z.string().uuid("Invalid supplier ID").nullable().optional(),
    cost_cents: z
      .number()
      .int("Cost must be an integer")
      .nonnegative("Cost cannot be negative")
      .optional(),
    price_cents: z
      .number()
      .int("Price must be an integer")
      .nonnegative("Price cannot be negative")
      .optional(),
    retail: z.boolean().optional(),
    active: z.boolean().optional(),
  }),
});

// Schema for getting a single product
export const getProductSchema = z.object({
  params: z.object({
    id: z.string().uuid("Invalid product ID"),
  }),
});

// Schema for deleting a product
export const deleteProductSchema = z.object({
  params: z.object({
    id: z.string().uuid("Invalid product ID"),
  }),
});

// Schema for product query parameters
export const productQuerySchema = z.object({
  query: z.object({
    page: z.coerce.number().int().positive().optional(),
    limit: z.coerce.number().int().positive().max(100).optional(),
    sort: z.string().optional(),
    search: z.string().optional(),
    category_id: z.string().uuid().optional(),
    supplier_id: z.string().uuid().optional(),
    active: z.enum(["true", "false"]).optional(),
    retail: z.enum(["true", "false"]).optional(),
  }),
});


================================================================================
FILE: backend/src\validators\sale.validator.ts
================================================================================

import { z } from "zod";

const CartItemSchema = z.object({
  id: z.string(),
  type: z.enum(["treatment", "product", "appointment"]),
  name: z.string(),
  price: z.number(), // Frontend sends number (dollars)
  quantity: z.number(),
  staffId: z.string().optional(),
  staffName: z.string().optional(),
  productId: z.string().optional(),
  treatmentId: z.string().optional(),
  appointmentId: z.string().optional(),
  discount: z.number().optional(), // Item level discount if any
});

const DiscountSchema = z.object({
  type: z.enum(["percentage", "fixed", "loyalty"]),
  value: z.number(),
  reason: z.string().optional(),
});

const PaymentBreakdownSchema = z.object({
  method: z.enum(["cash", "card", "loyalty", "gift-card"]),
  amount: z.number(),
  reference: z.string().optional(),
});

const TipsSchema = z.record(z.string(), z.number());

export const createSaleSchema = z.object({
  body: z.object({
    clientId: z.string().optional(),
    clientName: z.string().optional(), // In case of walk-in/new client
    items: z.array(CartItemSchema).min(1, "Cart cannot be empty"),
    discount: DiscountSchema,
    payments: z
      .array(PaymentBreakdownSchema)
      .min(1, "At least one payment method required"),
    tips: TipsSchema.optional(),
    loyaltyPointsRedeemed: z.number().optional(),
  }),
});


================================================================================
FILE: backend/src\validators\treatment.validator.ts
================================================================================

import { z } from "zod";

export const createTreatmentSchema = z.object({
  body: z.object({
    name: z.string().min(1),
    description: z.string().optional(),
    durationMinutes: z.number().int().min(1),
    price: z.number().nonnegative(),
    category: z.string().optional(),
    benefits: z.array(z.string()).optional(),
    contraindications: z.array(z.string()).optional(),
    preparationInstructions: z.string().optional(),
    aftercareInstructions: z.string().optional(),
    availableFor: z.array(z.string()).optional(), // expect array of IDs
    imageUrl: z.string().optional(),
    isActive: z.boolean().optional(),
    tags: z.array(z.string()).optional(),
  }),
});

export const updateTreatmentSchema = z.object({
  body: z.object({
    name: z.string().min(1).optional(),
    description: z.string().optional(),
    durationMinutes: z.number().int().min(1).optional(),
    price: z.number().nonnegative().optional(),
    category: z.string().optional(),
    benefits: z.array(z.string()).optional(),
    contraindications: z.array(z.string()).optional(),
    preparationInstructions: z.string().optional(),
    aftercareInstructions: z.string().optional(),
    availableFor: z.array(z.string()).optional(),
    imageUrl: z.string().optional(),
    isActive: z.boolean().optional(),
    tags: z.array(z.string()).optional(),
  }),
});
