// auth/src/middleware/auth.ts
import { Request, Response, NextFunction } from "express";
import catchAsync from "../utils/catchAsync.js";
import AppError from "../utils/appError.js";
import * as jwtUtils from "../config/jwt.js";
import User from "../models/userModel.js";
import { JWTPayload } from "jose";
import { logger } from "../utils/logger.js";

export const protect = catchAsync(
  async (req: any, res: Response, next: NextFunction) => {
    // 1) get token from header or cookie
    const authHeader = req.get("authorization");
    const tokenFromHeader =
      authHeader && authHeader.startsWith("Bearer ")
        ? authHeader.split(" ")[1]
        : undefined;
    const tokenFromCookie = req.cookies?.jwt;

    const token = tokenFromHeader || tokenFromCookie;
    if (!token) {
      return next(
        AppError.unauthorized(
          "You are not logged in! Please log in to get access."
        )
      );
    }

    // 2) verify token using jwt.ts
    let verified;
    try {
      verified = await jwtUtils.verifyToken(token);
    } catch (err: any) {
      // Token invalid/expired
      return next(AppError.unauthorized("Invalid or expired token"));
    }

    const payload = verified.payload as JWTPayload;
    // payload.sub is the standard subject claim; your signToken should set sub to user id
    const userId = payload.sub as string | undefined;
    if (!userId) {
      return next(
        AppError.unauthorized("Token does not contain subject (sub)")
      );
    }

    // 3) ensure user still exists
    const user = await User.findById(userId).select("+role +email"); // adjust select as needed
    if (!user) {
      return next(
        AppError.unauthorized(
          "The user belonging to this token no longer exists."
        )
      );
    }

    // 4) attach minimal user info
    req.user = {
      id: user.id,
      email: user.email,
      role: user.role,
    };

    next();
  }
);

export const restrictTo = (...roles: string[]) => {
  return (req: Request, res: Response, next: NextFunction) => {
    if (!req.user) {
      return next(AppError.unauthorized("You are not logged in"));
    }

    if (!roles.includes(req.user.role)) {
      logger.warn(
        `Unauthorized access attempt by user ${req.user.id} with role ${req.user.role}`
      );
      return next(
        AppError.forbidden("You do not have permission to perform this action")
      );
    }

    next();
  };
};


// auth/src/models/userModel.ts
// ./auth/src/models/userModel.ts
import mongoose, { Document, Types, Schema, Model } from "mongoose";
import validator from "validator";

export interface IUser extends Document {
  _id: Types.ObjectId;
  firstName?: string;
  lastName?: string;
  name?: string;
  email: string;
  phone?: string;
  role: "owner" | "admin" | "manager" | "therapist" | "receptionist";
  password: string;
  passwordChangedAt?: Date;
  passwordResetToken?: string;
  passwordResetExpires?: Date;
  active: boolean;
  profileImage?: string;
  specializations?: string[];
  bio?: string;
  hireDate?: Date;
  createdAt: Date;
  updatedAt: Date;
  lastLogin?: Date;
}

const userSchema = new Schema<IUser>(
  {
    firstName: {
      type: String,
      trim: true,
      maxlength: [50, "First name cannot exceed 50 characters"],
    },
    lastName: {
      type: String,
      trim: true,
      maxlength: [50, "Last name cannot exceed 50 characters"],
    },
    name: {
      type: String,
      trim: true,
      maxlength: [100, "Name cannot exceed 100 characters"],
    },
    email: {
      type: String,
      required: [true, "Email is required"],
      unique: true,
      lowercase: true,
      trim: true,
      validate: [validator.isEmail, "Please provide a valid email"],
      index: true,
    },
    phone: {
      type: String,
      trim: true,
      validate: {
        validator: function (v: string) {
          return !v || /^\+?[1-9]\d{1,14}$/.test(v);
        },
        message: "Please provide a valid phone number",
      },
    },
    role: {
      type: String,
      enum: {
        values: ["owner", "admin", "manager", "therapist", "receptionist"],
        message: "Role must be admin, manager, therapist, or receptionist",
      },
      default: "therapist",
      index: true,
    },
    password: {
      type: String,
      required: [true, "Password is required"],
      minlength: [8, "Password must be at least 8 characters"],
      select: false, // Don't return password by default
    },
    passwordChangedAt: {
      type: Date,
      select: false,
    },
    passwordResetToken: {
      type: String,
      select: false,
    },
    passwordResetExpires: {
      type: Date,
      select: false,
    },
    active: {
      type: Boolean,
      default: true,
      select: false,
    },
    profileImage: {
      type: String,
      validate: {
        validator: function (v: string) {
          return !v || validator.isURL(v);
        },
        message: "Please provide a valid URL for profile image",
      },
    },
    specializations: {
      type: [String],
      default: [],
    },
    bio: {
      type: String,
      maxlength: [500, "Bio cannot exceed 500 characters"],
    },
    hireDate: {
      type: Date,
    },
    lastLogin: {
      type: Date,
    },
  },
  {
    timestamps: true, // Adds createdAt and updatedAt
    toJSON: {
      virtuals: true,
      transform: function (doc, ret: { password?: string; __v?: any }) {
        delete ret.password;
        delete ret.__v;
        return ret;
      },
    },
    toObject: {
      virtuals: true,
      transform: function (doc, ret: { password?: string; __v?: any }) {
        delete ret.password;
        delete ret.__v;
        return ret;
      },
    },
  }
);

// Virtual for full name
userSchema.virtual("fullName").get(function (this: IUser) {
  if (this.firstName && this.lastName) {
    return `${this.firstName} ${this.lastName}`;
  }
  return this.name || this.email;
});

// Indexes
userSchema.index({ email: 1 });
userSchema.index({ role: 1 });
userSchema.index({ active: 1 });
userSchema.index({ createdAt: -1 });

// Query middleware - don't return inactive users by default
userSchema.pre(/^find/, function (next) {
  // Only filter if not explicitly querying for inactive users
  if (!(this as any).getOptions().includeInactive) {
    (this as any).find({ active: { $ne: false } });
  }
  next();
});

const User: Model<IUser> = mongoose.model<IUser>("User", userSchema);

export default User;


// auth/src/services/authService.ts
import argon2 from "argon2";
import crypto from "crypto";
import User, { IUser } from "../models/userModel.js";
import { tokenService } from "./tokenService.js";
import AppError from "../utils/appError.js";
import { logger } from "../utils/logger.js";
import { SignupInput, LoginInput } from "../utils/validators.js";

export class AuthService {
  async signup(data: SignupInput): Promise<{
    user: IUser;
    accessToken: string;
    refreshToken: string;
  }> {
    // Check if user already exists
    const existingUser = await User.findOne({ email: data.email });
    if (existingUser) {
      throw AppError.conflict("Email already in use");
    }

    // Hash password with Argon2id
    const passwordHash = await argon2.hash(data.password, {
      type: argon2.argon2id,
      memoryCost: 65536, // 64 MiB
      timeCost: 3,
      parallelism: 4,
    });

    // Create user
    const user = await User.create({
      email: data.email,
      password: passwordHash,
      firstName: data.firstName,
      lastName: data.lastName,
      name: data.name,
      role: data.role || "therapist",
    });

    logger.info(`New user created: ${user.email}`);

    // Generate tokens
    const { accessToken, refreshToken } = await tokenService.generateTokenPair(
      user
    );

    return { user, accessToken, refreshToken };
  }

  async login(
    credentials: LoginInput,
    ip?: string,
    userAgent?: string
  ): Promise<{
    user: IUser;
    accessToken: string;
    refreshToken: string;
  }> {
    // Find user with password field
    const user = await User.findOne({ email: credentials.email })
      .select("+password +active")
      .exec();

    // DEBUG: Log everything
    logger.info("=== LOGIN DEBUG ===");
    logger.info("Email:", credentials.email);
    logger.info("User found:", !!user);
    logger.info("===================");

    if (!user) {
      throw AppError.unauthorized("Invalid email or password");
    }

    // Verify password
    const isValidPassword = await argon2.verify(
      user.password,
      credentials.password
    );

    logger.info("=== PASSWORD VERIFICATION ===");
    logger.info("Is valid:", isValidPassword);
    logger.info("=============================");

    if (!isValidPassword) {
      logger.warn(`Failed login attempt for user: ${credentials.email}`);
      throw AppError.unauthorized("Invalid email or password");
    }

    // Check if user is active
    if (!user.active) {
      throw AppError.unauthorized("Your account has been deactivated");
    }

    // Update last login
    user.lastLogin = new Date();
    await user.save({ validateBeforeSave: false });

    logger.info(`User logged in: ${user.email}`);

    // Generate tokens
    const { accessToken, refreshToken } = await tokenService.generateTokenPair(
      user,
      ip,
      userAgent
    );

    return { user, accessToken, refreshToken };
  }

  async refreshTokens(
    refreshToken: string,
    ip?: string,
    userAgent?: string
  ): Promise<{ accessToken: string; refreshToken: string }> {
    // Validate refresh token
    const validation = await tokenService.validateRefreshToken(refreshToken);

    if (!validation.valid || !validation.userId) {
      throw AppError.unauthorized("Invalid or expired refresh token");
    }

    // Get user
    const user = await User.findById(validation.userId).select("+active");
    if (!user) {
      throw AppError.unauthorized("User no longer exists");
    }

    if (!user.active) {
      throw AppError.unauthorized("Your account has been deactivated");
    }

    // Revoke old token
    if (validation.jti) {
      await tokenService.revokeRefreshToken(validation.jti);
    }

    // Generate new token pair
    const tokens = await tokenService.generateTokenPair(user, ip, userAgent);

    logger.info(`Tokens refreshed for user: ${user.email}`);

    return tokens;
  }

  async logout(refreshToken: string): Promise<void> {
    try {
      const validation = await tokenService.validateRefreshToken(refreshToken);
      if (validation.valid && validation.jti) {
        await tokenService.revokeRefreshToken(validation.jti);
        logger.info(`User logged out, token revoked: ${validation.jti}`);
      }
    } catch (error) {
      logger.error("Logout error:", error);
      // Don't throw error on logout
    }
  }

  async updatePassword(
    userId: string,
    currentPassword: string,
    newPassword: string
  ): Promise<{ accessToken: string; refreshToken: string }> {
    // Get user with password
    const user = await User.findById(userId).select("+password");
    if (!user) {
      throw AppError.notFound("User not found");
    }

    // Verify current password
    const isValidPassword = await argon2.verify(user.password, currentPassword);

    if (!isValidPassword) {
      throw AppError.unauthorized("Current password is incorrect");
    }

    // Hash new password
    const passwordHash = await argon2.hash(newPassword, {
      type: argon2.argon2id,
      memoryCost: 65536,
      timeCost: 3,
      parallelism: 4,
    });

    // Update password
    user.password = passwordHash;
    user.passwordChangedAt = new Date();
    await user.save();

    logger.info(`Password updated for user: ${user.email}`);

    // Revoke all existing sessions
    await tokenService.revokeAllUserTokens(userId);

    // Generate new tokens
    const { accessToken, refreshToken } = await tokenService.generateTokenPair(
      user
    );

    return { accessToken, refreshToken };
  }

  async forgotPassword(email: string): Promise<string> {
    const user = await User.findOne({ email });
    if (!user) {
      // Don't reveal if user exists
      logger.warn(`Password reset requested for non-existent user: ${email}`);
      return ""; // Return empty token
    }

    // Generate reset token
    const resetToken = crypto.randomBytes(32).toString("hex");
    const hashedToken = crypto
      .createHash("sha256")
      .update(resetToken)
      .digest("hex");

    // Save to user
    user.passwordResetToken = hashedToken;
    user.passwordResetExpires = new Date(Date.now() + 10 * 60 * 1000); // 10 minutes
    await user.save({ validateBeforeSave: false });

    logger.info(`Password reset token generated for user: ${user.email}`);

    return resetToken; // Return unhashed token to send via email
  }

  async resetPassword(token: string, newPassword: string): Promise<void> {
    // Hash the token to compare with stored hash
    const hashedToken = crypto.createHash("sha256").update(token).digest("hex");

    // Find user with valid reset token
    const user = await User.findOne({
      passwordResetToken: hashedToken,
      passwordResetExpires: { $gt: Date.now() },
    });

    if (!user) {
      throw AppError.badRequest("Invalid or expired reset token");
    }

    // Hash new password
    const passwordHash = await argon2.hash(newPassword, {
      type: argon2.argon2id,
      memoryCost: 65536,
      timeCost: 3,
      parallelism: 4,
    });

    // Update password and clear reset token
    user.password = passwordHash;
    user.passwordChangedAt = new Date();
    user.passwordResetToken = undefined;
    user.passwordResetExpires = undefined;
    await user.save();

    logger.info(`Password reset completed for user: ${user.email}`);

    // Revoke all sessions
    await tokenService.revokeAllUserTokens(String(user._id));
  }
}

export const authService = new AuthService();

// auth/src/services/tokenService.ts
import crypto from "crypto";
import { JWTPayload } from "jose";
import { signToken } from "../config/jwt.js";
import { env } from "../config/env.js";
import Session, { hashToken } from "../models/sessionModel.js";
import { IUser } from "../models/userModel.js";
import { logger } from "../utils/logger.js";

export class TokenService {
  async generateAccessToken(user: IUser): Promise<string> {
    const payload: JWTPayload = {
      sub: String(user._id),
      email: user.email,
      role: user.role,
    };

    return await signToken(payload, `${env.ACCESS_TOKEN_TTL_SEC}s`);
  }

  async generateRefreshToken(user: IUser): Promise<string> {
    const jti = crypto.randomBytes(32).toString("hex");
    const payload: JWTPayload = {
      sub: String(user._id),
      email: user.email,
      role: user.role,
      jti,
    };

    return await signToken(payload, `${env.REFRESH_TOKEN_TTL_SEC}s`);
  }

  async generateTokenPair(
    user: IUser,
    ip?: string,
    userAgent?: string
  ): Promise<{ accessToken: string; refreshToken: string }> {
    const [accessToken, refreshToken] = await Promise.all([
      this.generateAccessToken(user),
      this.generateRefreshToken(user),
    ]);

    // Store refresh token session
    const jti = this.extractJtiFromToken(refreshToken);
    await this.storeRefreshSession(user, jti, refreshToken, ip, userAgent);

    return { accessToken, refreshToken };
  }

  async storeRefreshSession(
    user: IUser,
    jti: string,
    refreshToken: string,
    ip?: string,
    userAgent?: string
  ): Promise<void> {
    const expiresAt = new Date(Date.now() + env.REFRESH_TOKEN_TTL_SEC * 1000);

    await Session.create({
      user: user._id,
      jti,
      tokenHash: hashToken(refreshToken),
      expiresAt,
      ip,
      ua: userAgent,
    });

    logger.info(`Refresh session created for user ${user._id}`);
  }

  async validateRefreshToken(
    refreshToken: string
  ): Promise<{ valid: boolean; jti?: string; userId?: string }> {
    try {
      const jti = this.extractJtiFromToken(refreshToken);
      const tokenHash = hashToken(refreshToken);

      const session = await Session.findOne({ jti });

      if (!session) {
        logger.warn(`Session not found for jti: ${jti}`);
        return { valid: false };
      }

      if (session.revokedAt) {
        logger.warn(`Revoked token used: ${jti}`);
        return { valid: false };
      }

      if (session.expiresAt < new Date()) {
        logger.warn(`Expired token used: ${jti}`);
        return { valid: false };
      }

      if (session.tokenHash !== tokenHash) {
        logger.warn(`Token hash mismatch for jti: ${jti}`);
        return { valid: false };
      }

      return { valid: true, jti, userId: String(session.user) };
    } catch (error) {
      logger.error("Token validation error:", error);
      return { valid: false };
    }
  }

  async revokeRefreshToken(jti: string): Promise<void> {
    await Session.updateOne({ jti }, { $set: { revokedAt: new Date() } });
    logger.info(`Refresh token revoked: ${jti}`);
  }

  async revokeAllUserTokens(userId: string): Promise<void> {
    await Session.updateMany(
      { user: userId, revokedAt: null },
      { $set: { revokedAt: new Date() } }
    );
    logger.info(`All tokens revoked for user: ${userId}`);
  }

  private extractJtiFromToken(token: string): string {
    // Decode JWT without verification (we'll verify separately)
    const parts = token.split(".");
    if (parts.length !== 3) {
      throw new Error("Invalid token format");
    }

    const payload = JSON.parse(Buffer.from(parts[1], "base64url").toString());

    if (!payload.jti) {
      throw new Error("Token missing jti claim");
    }

    return payload.jti;
  }

  async cleanupExpiredSessions(): Promise<void> {
    const result = await Session.deleteMany({
      expiresAt: { $lt: new Date() },
    });
    logger.info(`Cleaned up ${result.deletedCount} expired sessions`);
  }
}

export const tokenService = new TokenService();

// auth/src/services/userService.ts
import User, { IUser } from "../models/userModel.js";
import AppError from "../utils/appError.js";
import { logger } from "../utils/logger.js";
import { UpdateUserInput } from "../utils/validators.js";

export class UserService {
  async getUser(userId: string): Promise<IUser> {
    const user = await User.findById(userId);

    if (!user) {
      throw AppError.notFound("User not found");
    }

    return user;
  }

  async getAllUsers(filters?: {
    role?: string;
    active?: boolean;
    search?: string;
  }): Promise<IUser[]> {
    const query: any = {};

    if (filters?.role) {
      query.role = filters.role;
    }

    if (filters?.active !== undefined) {
      query.active = filters.active;
    }

    if (filters?.search) {
      query.$or = [
        { email: { $regex: filters.search, $options: "i" } },
        { firstName: { $regex: filters.search, $options: "i" } },
        { lastName: { $regex: filters.search, $options: "i" } },
      ];
    }

    const users = await User.find(query).sort({ createdAt: -1 });
    return users;
  }

  async updateUser(userId: string, data: UpdateUserInput): Promise<IUser> {
    // Don't allow password updates through this method
    const updateData = { ...data };
    delete (updateData as any).password;
    delete (updateData as any).passwordConfirm;
    delete (updateData as any).role; // Only admins should change roles

    const user = await User.findByIdAndUpdate(userId, updateData, {
      new: true,
      runValidators: true,
    });

    if (!user) {
      throw AppError.notFound("User not found");
    }

    logger.info(`User updated: ${user.email}`);
    return user;
  }

  async deactivateUser(userId: string): Promise<void> {
    const user = await User.findByIdAndUpdate(
      userId,
      { active: false },
      { new: true }
    );

    if (!user) {
      throw AppError.notFound("User not found");
    }

    logger.info(`User deactivated: ${user.email}`);
  }

  async deleteUser(userId: string): Promise<void> {
    const user = await User.findByIdAndDelete(userId);

    if (!user) {
      throw AppError.notFound("User not found");
    }

    logger.info(`User permanently deleted: ${user.email}`);
  }

  async getUserStats(): Promise<{
    total: number;
    byRole: Record<string, number>;
    active: number;
    inactive: number;
  }> {
    const [total, byRole, active, inactive] = await Promise.all([
      User.countDocuments(),
      User.aggregate([{ $group: { _id: "$role", count: { $sum: 1 } } }]),
      User.countDocuments({ active: true }),
      User.countDocuments({ active: false }),
    ]);

    const roleStats: Record<string, number> = {};
    byRole.forEach((item) => {
      roleStats[item._id] = item.count;
    });

    return {
      total,
      byRole: roleStats,
      active,
      inactive,
    };
  }
}

export const userService = new UserService();

// api-proxy-server/src/routes/authRoutes.ts
import { Router } from "express";
import { createProxy } from "../proxies/proxyFactory.js";
import { env } from "../config/env.js";
import { authLimiter } from "../middleware/rateLimiter.js";
import { protect } from "../middleware/authMiddleware.js";

const router = Router();

// Apply strict rate limiting to auth routes
router.use(authLimiter);

// PUBLIC routes - no authentication required
const publicAuthProxy = createProxy({
  target: env.AUTH_SERVICE_URL,
  pathRewrite: { "^/auth": "" },
});

// PROTECTED routes - authentication required
const protectedAuthProxy = createProxy({
  target: env.AUTH_SERVICE_URL,
  pathRewrite: { "^/auth": "" },
});

// --- PUBLIC routes ---
router.post("/signup", publicAuthProxy);
router.post("/login", publicAuthProxy);
router.post("/refresh", publicAuthProxy);
router.post("/logout", publicAuthProxy);
router.post("/forgot-password", publicAuthProxy);
router.patch("/reset-password/:token", publicAuthProxy);

// --- PROTECTED routes ---
router.get("/me", protect, protectedAuthProxy);
router.patch("/update-password", protect, protectedAuthProxy);

export default router;


// api-proxy-server/src/routes/apiRoutes.ts
import { Router } from "express";
import { createProxy } from "../proxies/proxyFactory.js";
import { env } from "../config/env.js";

const router = Router();

// User management (from auth service)
router.use(
  "/users",
  createProxy({
    target: env.AUTH_SERVICE_URL,
    pathRewrite: { "^/api/v1/users": "/api/v1/users" },
    isBackendService: false, // Auth service doesn't need GATEWAY_SECRET
  })
);

// Inventory service routes - ALL need GATEWAY_SECRET
const inventoryRoutes = [
  "products",
  "categories",
  "suppliers",
  "locations",
  "treatments",
  "inventory",
  "sales",
  "clients",
  "appointments",
  "staff",
  "bookings",
  "stock",
];

inventoryRoutes.forEach((route) => {
  router.use(
    `/${route}`,
    createProxy({
      target: env.INVENTORY_SERVICE_URL,
      isBackendService: true,
    })
  );
});

export default router;


// api-proxy-server/src/proxies/proxyFactory.ts
import proxy from "express-http-proxy";
import { Request, Response } from "express";
import { logger } from "../utils/logger.js";
import { env } from "../config/env.js";

export interface ProxyConfig {
  target: string;
  pathRewrite?: Record<string, string>;
  timeout?: number;
  isBackendService?: boolean;
}

export const createProxy = (config: ProxyConfig) => {
  const {
    target,
    pathRewrite,
    timeout = 30000,
    isBackendService = false,
  } = config;

  return proxy(target, {
    timeout,

    proxyReqPathResolver: (req) => {
      let newPath = `${req.baseUrl}${req.url}`;
      if (pathRewrite) {
        for (const [pattern, replacement] of Object.entries(pathRewrite)) {
          const regex = new RegExp(pattern);
          newPath = newPath.replace(regex, replacement);
        }
      }
      logger.debug("üîÅ Proxying request", {
        method: req.method,
        baseUrl: req.baseUrl,
        url: req.url,
        newPath,
        target,
      });

      return newPath;
    },

    parseReqBody: true,

    proxyReqOptDecorator: (proxyReqOpts, srcReq: Request) => {
      // Inject gateway secret for backend services
      if (isBackendService && env.GATEWAY_SECRET) {
        proxyReqOpts.headers = proxyReqOpts.headers || {};
        proxyReqOpts.headers["x-gateway-key"] = env.GATEWAY_SECRET;
      }

      // Forward cookies
      if (srcReq.headers.cookie) {
        proxyReqOpts.headers = proxyReqOpts.headers || {};
        proxyReqOpts.headers["cookie"] = srcReq.headers.cookie;
      }

      // Forward or create Authorization header from JWT cookie
      if (srcReq.headers.authorization) {
        proxyReqOpts.headers = proxyReqOpts.headers || {};
        proxyReqOpts.headers["authorization"] = srcReq.headers.authorization;
      } else if (srcReq.headers.cookie) {
        const jwtMatch = srcReq.headers.cookie.match(/(?:^|;\s*)jwt=([^;]+)/);
        if (jwtMatch && jwtMatch[1]) {
          proxyReqOpts.headers = proxyReqOpts.headers || {};
          proxyReqOpts.headers["authorization"] = `Bearer ${jwtMatch[1]}`;
        }
      }

      // Forward user context headers (this is the key part!)
      if (srcReq.user) {
        proxyReqOpts.headers = proxyReqOpts.headers || {};
        if (srcReq.user.id) {
          proxyReqOpts.headers["x-user-id"] = String(srcReq.user.id);
        }
        if (srcReq.user.email) {
          proxyReqOpts.headers["x-user-email"] = String(srcReq.user.email);
        }
        if (srcReq.user.role) {
          proxyReqOpts.headers["x-user-role"] = String(srcReq.user.role);
        }

        logger.debug("‚úÖ Forwarding user headers:", {
          "x-user-id": srcReq.user.id,
          "x-user-email": srcReq.user.email,
          "x-user-role": srcReq.user.role,
        });
      } else {
        logger.warn("‚ö†Ô∏è No user found in request - headers not forwarded");
      }

      return proxyReqOpts;
    },

    userResDecorator: (proxyRes, proxyResData, userReq, userRes) => {
      return proxyResData;
    },

    proxyErrorHandler: (err, res: Response, next) => {
      logger.error("Proxy error", {
        target,
        error: err?.message || String(err),
      });

      if (!res.headersSent) {
        res.status(503).json({
          status: "error",
          message: "Upstream service unavailable",
          service: target,
          error: err?.message,
        });
      }
    },
  });
};


// api-proxy-server/src/middleware/authMiddleware.ts
import { Request, Response, NextFunction } from "express";
import { jwtVerify, createRemoteJWKSet } from "jose";
import AppError from "../utils/appError.js";
import catchAsync from "../utils/catchAsync.js";
import { env } from "../config/env.js";
import logger from "../utils/logger.js";

interface JwtPayload {
  sub: string;
  email: string;
  role: string;
  iat: number;
  exp: number;
  iss: string;
  aud: string;
}

export interface AuthRequest extends Request {
  user?: {
    id: string;
    email: string;
    role: string;
  };
}

// Create JWKS fetcher for verifying RSA signatures
const JWKS = createRemoteJWKSet(new URL(env.JWKS_URL));

export const protect = catchAsync(
  async (req: AuthRequest, res: Response, next: NextFunction) => {
    logger.debug("\nüîí PROTECT MIDDLEWARE");

    // 1) Get token from header or cookie
    let token: string | undefined;

    if (
      req.headers.authorization &&
      req.headers.authorization.startsWith("Bearer")
    ) {
      token = req.headers.authorization.split(" ")[1];
      logger.info("‚úÖ Token from Authorization header");
    } else if (req.cookies.jwt) {
      token = req.cookies.jwt;
      logger.info("‚úÖ Token from jwt cookie");
    }

    if (!token) {
      logger.warn("‚ùå No token found");
      return next(
        new AppError("You are not logged in! Please log in to get access.", 401)
      );
    }

    // 2) Verify token using RSA public key from JWKS
    let decoded: JwtPayload;
    try {
      logger.info("üîç Verifying token with JWKS...");
      const { payload } = await jwtVerify(token, JWKS, {
        issuer: env.JWT_ISSUER,
        audience: env.JWT_AUDIENCE,
      });

      decoded = payload as unknown as JwtPayload;
      logger.info("‚úÖ Token verified successfully");
      logger.info("User:", decoded.sub, decoded.email, decoded.role);
    } catch (err: any) {
      logger.warn("‚ùå Token verification failed:", err.message);
      if (err.code === "ERR_JWT_EXPIRED") {
        return next(
          new AppError("Your token has expired! Please log in again.", 401)
        );
      }
      return next(new AppError("Invalid token. Please log in again!", 401));
    }

    // 3) Attach user to request
    req.user = {
      id: decoded.sub,
      email: decoded.email,
      role: decoded.role,
    };

    logger.debug("‚úÖ User attached to request\n");
    next();
  }
);

export const restrictTo = (...roles: string[]) => {
  return (req: AuthRequest, res: Response, next: NextFunction) => {
    if (!req.user || !roles.includes(req.user.role)) {
      return next(
        new AppError("You do not have permission to perform this action", 403)
      );
    }
    next();
  };
};


// backend/src/validators/client.validator.ts
import { z } from "zod";

/**
 * Schema for creating a new client
 */
export const createClientSchema = z.object({
  body: z.object({
    name: z
      .string()
      .min(1, "Name is required")
      .max(200, "Name must be less than 200 characters")
      .trim(),
    email: z
      .string()
      .email("Invalid email address")
      .max(255, "Email must be less than 255 characters")
      .toLowerCase()
      .trim()
      .optional()
      .or(z.literal("")),
    phone: z
      .string()
      .min(1, "Phone number is required")
      .max(50, "Phone number must be less than 50 characters")
      .trim()
      .regex(/^[\d\s\+\-\(\)]+$/, "Phone number contains invalid characters"),
    whatsapp: z
      .string()
      .max(50, "WhatsApp number must be less than 50 characters")
      .trim()
      .optional(),
    notes: z
      .string()
      .max(1000, "Notes must be less than 1000 characters")
      .optional(),
    date_of_birth: z
      .string()
      .refine(
        (date) => {
          if (!date) return true; // Allow empty/undefined
          const parsed = new Date(date);
          return !isNaN(parsed.getTime());
        },
        { message: "Invalid date format" }
      )
      .optional(),
    address: z
      .string()
      .max(500, "Address must be less than 500 characters")
      .optional(),
  }),
});

/**
 * Schema for updating a client
 */
export const updateClientSchema = z.object({
  body: z.object({
    name: z
      .string()
      .min(1, "Name cannot be empty")
      .max(200, "Name must be less than 200 characters")
      .trim()
      .optional(),
    email: z
      .string()
      .email("Invalid email address")
      .max(255, "Email must be less than 255 characters")
      .toLowerCase()
      .trim()
      .optional()
      .or(z.literal("")),
    phone: z
      .string()
      .min(1, "Phone number cannot be empty")
      .max(50, "Phone number must be less than 50 characters")
      .trim()
      .regex(/^[\d\s\+\-\(\)]+$/, "Phone number contains invalid characters")
      .optional(),
    whatsapp: z
      .string()
      .max(50, "WhatsApp number must be less than 50 characters")
      .trim()
      .optional(),
    notes: z
      .string()
      .max(1000, "Notes must be less than 1000 characters")
      .optional(),
    date_of_birth: z
      .string()
      .refine(
        (date) => {
          if (!date) return true;
          const parsed = new Date(date);
          return !isNaN(parsed.getTime());
        },
        { message: "Invalid date format" }
      )
      .optional(),
    address: z
      .string()
      .max(500, "Address must be less than 500 characters")
      .optional(),
  }),
  params: z.object({
    id: z.string().uuid("Invalid client ID"),
  }),
});

/**
 * Schema for searching clients
 */
export const searchClientSchema = z.object({
  query: z.object({
    q: z
      .string()
      .max(100, "Search term must be less than 100 characters")
      .optional(),
  }),
});

/**
 * Schema for getting client by ID
 */
export const getClientSchema = z.object({
  params: z.object({
    id: z.string().uuid("Invalid client ID"),
  }),
});

/**
 * Schema for getting all clients with pagination
 */
export const getAllClientsSchema = z.object({
  query: z.object({
    q: z
      .string()
      .max(100, "Search term must be less than 100 characters")
      .optional(),
    page: z.coerce
      .number()
      .int("Page must be an integer")
      .positive("Page must be positive")
      .optional(),
    limit: z.coerce
      .number()
      .int("Limit must be an integer")
      .positive("Limit must be positive")
      .max(100, "Limit cannot exceed 100")
      .optional(),
  }),
});

// backend/src/routes/clientRoutes.ts
import { Router } from "express";
import {
  createClient,
  getAllClients,
  searchClients,
  getClient,
  updateClient,
  getClientHistory,
  getClientStats,
  deleteClient,
} from "../controllers/clientController.js";
import { restrictTo } from "../middleware/userMiddleware.js";
import { validateUUID } from "../middleware/validation.js";

const router = Router();

// Search endpoint (before /:id to avoid conflicts)
router.get("/search", searchClients);

// CRUD operations
router
  .route("/")
  .get(getAllClients)
  .post(
    restrictTo("admin", "manager", "owner", "receptionist", "therapist"),
    createClient
  );

router
  .route("/:id")
  .get(validateUUID("id"), getClient)
  .patch(
    validateUUID("id"),
    restrictTo("admin", "manager", "owner", "receptionist", "therapist"),
    updateClient
  )
  .delete(
    validateUUID("id"),
    restrictTo("owner", "manager", "admin"),
    deleteClient
  );

// Client history and stats
router.get("/:id/history", validateUUID("id"), getClientHistory);
router.get(
  "/:id/stats",
  validateUUID("id"),
  restrictTo("admin", "owner", "manager"),
  getClientStats
);

export default router;

// backend/src/config/database.ts
import { Pool, PoolConfig, QueryResultRow } from "pg";
import { env } from './env.js';
import {
  logger,
  logStartup,
  logShutdown,
  logDatabaseConnection,
} from '../utils/logger.js';

// Database configuration
const config: PoolConfig = {
  connectionString: env.DATABASE_URL,
  max: 20,
  idleTimeoutMillis: 30000,
  connectionTimeoutMillis: 5000,
  // NOTE: acceptSupabaseHostedCert is true by default in many examples
  ssl:
    env.DB_SSL === "true" || Boolean(env.DATABASE_URL)
      ? { rejectUnauthorized: env.DB_SSL === "true" ? false : true }
      : false,
};

// Create the connection pool
export const pool = new Pool(config);

// Handle pool errors
pool.on("error", (err, client) => {
  logger.error("Unexpected error on idle client", err);
  // Don't exit the process, but log the error
});

// Handle pool connection events
pool.on("connect", () => {
  logDatabaseConnection("success", {
    host: "localhost",
    database: "postgres",
  });
});

pool.on("remove", () => {
  logger.info("üîå Database client removed from pool");
});

/**
 * Test database connection
 * @returns Promise<boolean> - true if connection successful
 */
export const testConnection = async (): Promise<boolean> => {
  try {
    const res = await pool.query("SELECT NOW() as now, version() as version");
    logger.info("‚úÖ PostgreSQL connected successfully");
    logger.info(`   Time: ${res.rows[0].now}`);
    logger.info(`   Version: ${res.rows[0].version.split(",")[0]}`);
    return true;
  } catch (err) {
    logger.error("‚ùå Database connection failed:", err);
    return false;
  }
};

/**
 * Execute a query with type safety
 * @param text - SQL query string
 * @param params - Query parameters
 * @returns Promise with typed result
 */
export const query = <T extends QueryResultRow = any>(
  text: string,
  params?: any[]
) => pool.query<T>(text, params);

/**
 * Get a client from the pool for transactions
 * @returns Promise with PoolClient
 */
export const getClient = () => pool.connect();

/**
 * Close all pool connections gracefully
 */
export const closePool = async (): Promise<void> => {
  try {
    await pool.end();
    logger.warn("üîí Database pool closed successfully");
  } catch (err) {
    logger.error("Error closing database pool:", err);
    throw err;
  }
};

// ./docker-compose.prod.yml
// I havent tested this yet
services:
  # Traefik - Reverse Proxy with Automatic SSL
  traefik:
    image: traefik:v2.10
    container_name: studio-s-traefik
    restart: unless-stopped
    security_opt:
      - no-new-privileges:true
    networks:
      - studio-s-network
    ports:
      - "80:80"     # HTTP
      - "443:443"   # HTTPS
      - "8080:8080" # Traefik Dashboard (disable in production)
    environment:
      - CF_API_EMAIL=${CLOUDFLARE_EMAIL}  # If using Cloudflare DNS
      - CF_DNS_API_TOKEN=${CLOUDFLARE_API_TOKEN}
    volumes:
      - /etc/localtime:/etc/localtime:ro
      - /var/run/docker.sock:/var/run/docker.sock:ro
      - ./traefik/traefik.yml:/traefik.yml:ro
      - ./traefik/acme.json:/acme.json
      - ./traefik/config.yml:/config.yml:ro
    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.traefik.entrypoints=http"
      - "traefik.http.routers.traefik.rule=Host(`traefik.yourdomain.com`)"
      - "traefik.http.middlewares.traefik-auth.basicauth.users=admin:$$apr1$$..." # htpasswd
      - "traefik.http.middlewares.traefik-https-redirect.redirectscheme.scheme=https"
      - "traefik.http.middlewares.sslheader.headers.customrequestheaders.X-Forwarded-Proto=https"
      - "traefik.http.routers.traefik.middlewares=traefik-https-redirect"
      - "traefik.http.routers.traefik-secure.entrypoints=https"
      - "traefik.http.routers.traefik-secure.rule=Host(`traefik.yourdomain.com`)"
      - "traefik.http.routers.traefik-secure.middlewares=traefik-auth"
      - "traefik.http.routers.traefik-secure.tls=true"
      - "traefik.http.routers.traefik-secure.tls.certresolver=cloudflare"
      - "traefik.http.routers.traefik-secure.service=api@internal"

  # Auth Service
  auth:
    build:
      context: ./auth
      dockerfile: Dockerfile
    container_name: studio-s-auth
    environment:
      - NODE_ENV=production
      - LOG_LEVEL=warn
      - SERVICE_NAME=auth-service
      - PORT=5002
      - MONGODB_URI=${MONGODB_URI}
      - JWT_ISSUER=studio-s-auth
      - JWT_AUDIENCE=studio-s-clients
      - JWT_KID=studio-s-auth-1
      - ACCESS_TOKEN_TTL_SEC=172800
      - REFRESH_TOKEN_TTL_SEC=1209600
      - COOKIE_SECURE=true  # Enable for HTTPS
      - COOKIE_SAMESITE=lax
      - TRUST_PROXY=true    # Trust Traefik proxy
      - CORS_ORIGIN=https://yourdomain.com
      - SELF_JWKS_URL=http://auth:5002/.well-known/jwks.json
    expose:
      - "5002"
    networks:
      - studio-s-network
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "wget", "--no-verbose", "--tries=1", "--spider", "http://localhost:5002/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s

  # Backend Service
  backend:
    build:
      context: ./backend
      dockerfile: Dockerfile
    container_name: studio-s-backend
    environment:
      - NODE_ENV=production
      - LOG_LEVEL=warn
      - DB_POOL_LOGGING=false
      - SERVICE_NAME=backend-service
      - PORT=5003
      - DB_SSL=true
      - DATABASE_URL=${DATABASE_URL}
      - REDIS_URL=redis://redis:6379
      - JWT_SECRET=${JWT_SECRET}
      - AUTH_SERVICE_URL=http://auth:5002
      - GATEWAY_SECRET=${GATEWAY_SECRET}
    expose:
      - "5003"
    networks:
      - studio-s-network
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "wget", "--no-verbose", "--tries=1", "--spider", "http://localhost:5003/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s

  # API Gateway
  gateway:
    build:
      context: ./api-proxy-server
      dockerfile: Dockerfile
    container_name: studio-s-gateway
    environment:
      - NODE_ENV=production
      - LOG_LEVEL=warn
      - SERVICE_NAME=api-gateway
      - PORT=4000
      - AUTH_SERVICE_URL=http://auth:5002
      - INVENTORY_SERVICE_URL=http://backend:5003
      - FRONTEND_URL=https://yourdomain.com
      - FRONTEND_URLS=https://yourdomain.com,https://www.yourdomain.com
      - JWKS_URL=http://auth:5002/.well-known/jwks.json
      - JWT_ISSUER=studio-s-auth
      - JWT_AUDIENCE=studio-s-clients
      - RATE_LIMIT_MAX_REQUESTS=100
      - RATE_LIMIT_WINDOW_MS=900000
      - REDIS_URL=redis://redis:6379
      - JWT_SECRET=${JWT_SECRET}
      - JWT_EXPIRES_IN=90d
      - GATEWAY_SECRET=${GATEWAY_SECRET}
    expose:
      - "4000"
    networks:
      - studio-s-network
    depends_on:
      auth:
        condition: service_healthy
      backend:
        condition: service_healthy
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "wget", "--no-verbose", "--tries=1", "--spider", "http://localhost:4000/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s

  # Frontend with Traefik Labels
  frontend:
    build:
      context: ./frontend
      dockerfile: Dockerfile
    container_name: studio-s-frontend
    environment:
      - NODE_ENV=production
      - VITE_API_BASE_URL=/api
    networks:
      - studio-s-network
    depends_on:
      gateway:
        condition: service_healthy
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"
    restart: unless-stopped
    labels:
      - "traefik.enable=true"
      # HTTP Router
      - "traefik.http.routers.frontend.entrypoints=http"
      - "traefik.http.routers.frontend.rule=Host(`yourdomain.com`) || Host(`www.yourdomain.com`)"
      - "traefik.http.middlewares.frontend-https-redirect.redirectscheme.scheme=https"
      - "traefik.http.routers.frontend.middlewares=frontend-https-redirect"
      # HTTPS Router
      - "traefik.http.routers.frontend-secure.entrypoints=https"
      - "traefik.http.routers.frontend-secure.rule=Host(`yourdomain.com`) || Host(`www.yourdomain.com`)"
      - "traefik.http.routers.frontend-secure.tls=true"
      - "traefik.http.routers.frontend-secure.tls.certresolver=cloudflare"
      - "traefik.http.routers.frontend-secure.service=frontend"
      - "traefik.http.services.frontend.loadbalancer.server.port=80"
      # Security Headers
      - "traefik.http.middlewares.security-headers.headers.frameDeny=true"
      - "traefik.http.middlewares.security-headers.headers.contentTypeNosniff=true"
      - "traefik.http.middlewares.security-headers.headers.browserXssFilter=true"
      - "traefik.http.middlewares.security-headers.headers.stsSeconds=31536000"
      - "traefik.http.middlewares.security-headers.headers.stsIncludeSubdomains=true"
      - "traefik.http.routers.frontend-secure.middlewares=security-headers"
    healthcheck:
      test: ["CMD", "wget", "--no-verbose", "--tries=1", "--spider", "http://localhost/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 10s

  # Redis
  redis:
    image: redis:7-alpine
    container_name: studio-s-redis
    expose:
      - "6379"
    networks:
      - studio-s-network
    volumes:
      - redis-data:/data
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 30s
      timeout: 10s
      retries: 3

  # Prometheus - Metrics Collection
  prometheus:
    image: prom/prometheus:latest
    container_name: studio-s-prometheus
    restart: unless-stopped
    volumes:
      - ./monitoring/prometheus.yml:/etc/prometheus/prometheus.yml
      - prometheus-data:/prometheus
    command:
      - '--config.file=/etc/prometheus/prometheus.yml'
      - '--storage.tsdb.path=/prometheus'
      - '--storage.tsdb.retention.time=30d'
    expose:
      - "9090"
    networks:
      - studio-s-network
    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.prometheus.rule=Host(`prometheus.yourdomain.com`)"
      - "traefik.http.routers.prometheus.entrypoints=https"
      - "traefik.http.routers.prometheus.tls=true"
      - "traefik.http.routers.prometheus.tls.certresolver=cloudflare"
      - "traefik.http.services.prometheus.loadbalancer.server.port=9090"

  # Grafana - Metrics Visualization
  grafana:
    image: grafana/grafana:latest
    container_name: studio-s-grafana
    restart: unless-stopped
    environment:
      - GF_SECURITY_ADMIN_USER=${GRAFANA_ADMIN_USER:-admin}
      - GF_SECURITY_ADMIN_PASSWORD=${GRAFANA_ADMIN_PASSWORD}
      - GF_INSTALL_PLUGINS=grafana-clock-panel
    volumes:
      - grafana-data:/var/lib/grafana
      - ./monitoring/grafana/provisioning:/etc/grafana/provisioning
    expose:
      - "3000"
    networks:
      - studio-s-network
    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.grafana.rule=Host(`grafana.yourdomain.com`)"
      - "traefik.http.routers.grafana.entrypoints=https"
      - "traefik.http.routers.grafana.tls=true"
      - "traefik.http.routers.grafana.tls.certresolver=cloudflare"
      - "traefik.http.services.grafana.loadbalancer.server.port=3000"

  # Loki - Log Aggregation
  loki:
    image: grafana/loki:latest
    container_name: studio-s-loki
    restart: unless-stopped
    volumes:
      - ./monitoring/loki-config.yml:/etc/loki/local-config.yaml
      - loki-data:/loki
    expose:
      - "3100"
    networks:
      - studio-s-network
    command: -config.file=/etc/loki/local-config.yaml

  # Promtail - Log Shipper
  promtail:
    image: grafana/promtail:latest
    container_name: studio-s-promtail
    restart: unless-stopped
    volumes:
      - ./monitoring/promtail-config.yml:/etc/promtail/config.yml
      - /var/lib/docker/containers:/var/lib/docker/containers:ro
      - /var/run/docker.sock:/var/run/docker.sock
    networks:
      - studio-s-network
    command: -config.file=/etc/promtail/config.yml

networks:
  studio-s-network:
    driver: bridge
    name: studio-s-network

volumes:
  redis-data:
    name: studio-s-redis-data
  prometheus-data:
    name: studio-s-prometheus-data
  grafana-data:
    name: studio-s-grafana-data
  loki-data:
    name: studio-s-loki-data
    
// ./docker-compose.yml
// tested and working for local dev
services:
  # Auth Service
  auth:
    build:
      context: ./auth
      dockerfile: Dockerfile
    container_name: studio-s-auth
    environment:
      - NODE_ENV=production
      - LOG_LEVEL=warn
      - SERVICE_NAME=auth-service
      - PORT=5002
      - MONGODB_URI=mongodb+srv://db_user:password@cluster0.mongodb.net/?appName=Cluster0
      - JWT_ISSUER=studio-s-auth
      - JWT_AUDIENCE=studio-s-clients
      - JWT_KID=studio-s-auth-1
      - ACCESS_TOKEN_TTL_SEC=172800
      - REFRESH_TOKEN_TTL_SEC=1209600
      - COOKIE_SECURE=false
      - COOKIE_SAMESITE=lax
      - TRUST_PROXY=loopback
      # Only allow requests from gateway (internal network only)
      - CORS_ORIGIN=http://gateway:4000
      - SELF_JWKS_URL=http://auth:5002/.well-known/jwks.json
    # NO external port exposure - only accessible via Docker network
    expose:
      - "5002"
    networks:
      - studio-s-network
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "wget", "--no-verbose", "--tries=1", "--spider", "http://localhost:5002/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s

  # Backend Service
  backend:
    build:
      context: ./backend
      dockerfile: Dockerfile
    container_name: studio-s-backend
    environment:
      - NODE_ENV=production
      - LOG_LEVEL=warn
      - DB_POOL_LOGGING=false
      - SERVICE_NAME=backend-service
      - PORT=5003
      - DB_SSL=true
      - DATABASE_URL=postgresql://postgres.:@central-1.pooler.supabase.com:5432/postgres
      - REDIS_URL=redis://redis:6379
      - JWT_SECRET=your-super-secret-jwt-key-change-in-production-min-32-chars
      - AUTH_SERVICE_URL=http://auth:5002
      - GATEWAY_SECRET=your-very-secure-gateway-secret-change-in-production
    # NO external port exposure - only accessible via Docker network
    expose:
      - "5003"
    networks:
      - studio-s-network
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "wget", "--no-verbose", "--tries=1", "--spider", "http://localhost:5003/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s

  # API Gateway
  gateway:
    build:
      context: ./api-proxy-server
      dockerfile: Dockerfile
    container_name: studio-s-gateway
    environment:
      - NODE_ENV=production
      - LOG_LEVEL=warn
      - SERVICE_NAME=api-gateway
      - PORT=4000
      - AUTH_SERVICE_URL=http://auth:5002
      - INVENTORY_SERVICE_URL=http://backend:5003
      # Allow both nginx internal requests AND browser origin
      - FRONTEND_URL=http://localhost:5173
      - FRONTEND_URLS=http://localhost:5173,http://frontend:80
      - JWKS_URL=http://auth:5002/.well-known/jwks.json
      - JWT_ISSUER=studio-s-auth
      - JWT_AUDIENCE=studio-s-clients
      - RATE_LIMIT_MAX_REQUESTS=100
      - RATE_LIMIT_WINDOW_MS=900000
      - REDIS_URL=redis://redis:6379
      - JWT_SECRET=your-super-secret-jwt-key-change-in-production
      - JWT_EXPIRES_IN=90d
      - GATEWAY_SECRET=your-very-secure-gateway-secret-change-in-production
    # NO external port exposure - only accessible via Docker network
    expose:
      - "4000"
    networks:
      - studio-s-network
    depends_on:
      auth:
        condition: service_healthy
      backend:
        condition: service_healthy
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "wget", "--no-verbose", "--tries=1", "--spider", "http://localhost:4000/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s

  # Frontend (Nginx)
  frontend:
    build:
      context: ./frontend
      dockerfile: Dockerfile
    container_name: studio-s-frontend
    environment:
      - NODE_ENV=production
      # IMPORTANT: This is used by docker-entrypoint.sh to generate env.js at runtime
      - VITE_API_BASE_URL=/api
    ports:
      # Only expose frontend to host
      - "5173:80"
    networks:
      - studio-s-network
    depends_on:
      gateway:
        condition: service_healthy
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "wget", "--no-verbose", "--tries=1", "--spider", "http://localhost/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 10s

  # Redis (if you don't have it already)
  redis:
    image: redis:7-alpine
    container_name: studio-s-redis
    expose:
      - "6379"
    networks:
      - studio-s-network
    volumes:
      - redis-data:/data
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 30s
      timeout: 10s
      retries: 3

networks:
  studio-s-network:
    driver: bridge
    name: studio-s-network

volumes:
  redis-data:
    name: studio-s-redis-data