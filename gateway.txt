Code combined from: C:\Users\p01mansoorg\Documents\python\Studio-S_manager\api-proxy-server\src
================================================================================



================================================================================
FILE: api-proxy-server/src\app.ts
================================================================================

import express, { Application, Request, Response, NextFunction } from "express";
import morgan from "morgan";
import helmet from "helmet";
import cors from "cors";
import cookieParser from "cookie-parser";
import { corsOptions } from "./config/cors.js";
import AppError from "./utils/appError.js";
import { errorHandler } from "./middleware/errorHandler.js";
import { setupRoutes } from "./routes/index.js";
import { requestId } from "./middleware/requestId.js";
import { requestLogger } from "./middleware/requestLogger.js";
import { env } from "./config/env.js";
import { queryParser } from "./middleware/queryParser.js";
import bodyParser from "body-parser";

const app: Application = express();

// Trust proxy
app.set("trust proxy", 1);

// Disable x-powered-by header
app.disable("x-powered-by");

// 1) GLOBAL MIDDLEWARES
app.use(
  helmet({
    contentSecurityPolicy: false,
    crossOriginResourcePolicy: { policy: "cross-origin" },
  })
);

if (process.env.NODE_ENV === "development") {
  app.use(morgan("dev"));
}

// CORS
app.use(cors(corsOptions));

// Handle preflight requests explicitly
// app.options("*", cors(corsOptions));

// Body parser
app.use((req, res, next) => {
  if (req.path.startsWith("/auth")) {
    return next(); // leave body as stream for proxy
  }
  return bodyParser.json({ limit: "10kb" })(req, res, next);
});

app.use(
  express.urlencoded({
    extended: true,
    limit: "10kb",
    parameterLimit: 1000,
  })
);

// Cookie parser
app.use(cookieParser());

// Request ID for correlation
app.use(requestId);
if (env.NODE_ENV !== "test") {
  app.use(requestLogger);
}

app.use(queryParser);

// Setup routes
setupRoutes(app);

// 404 handler for undefined routes
app.all(/.*/, (req: Request, res: Response, next: NextFunction) => {
  next(new AppError(`Cannot find ${req.originalUrl} on this server`, 404));
});

// Global error handler
app.use(errorHandler);

export default app;


================================================================================
FILE: api-proxy-server/src\server.ts
================================================================================

import { env } from "./config/env.js";
import { logger } from "./utils/logger.js";
import app from "./app.js";

const server = app.listen(env.PORT, () => {
  logger.info(`ðŸš€ API Gateway running on port ${env.PORT}`);
  logger.info(`ðŸ“ Environment: ${env.NODE_ENV}`);
  logger.info(`ðŸ” Auth Service: ${env.AUTH_SERVICE_URL}`);
  logger.info(`ðŸ“¦ Inventory Service: ${env.INVENTORY_SERVICE_URL}`);
});

// Graceful shutdown handler
const gracefulShutdown = async (signal: string) => {
  logger.info(`${signal} received. Starting graceful shutdown...`);

  server.close(() => {
    logger.info("HTTP server closed");
    process.exit(0);
  });

  // Force shutdown after 30 seconds
  setTimeout(() => {
    logger.error(
      "Could not close connections in time, forcefully shutting down"
    );
    process.exit(1);
  }, 30000);
};

// Error handlers
process.on("unhandledRejection", (err: any) => {
  logger.error("UNHANDLED REJECTION! ðŸ’¥", {
    message: err?.message || err,
    stack: err?.stack,
  });
  gracefulShutdown("UNHANDLED_REJECTION");
});

process.on("uncaughtException", (err: Error) => {
  logger.error("UNCAUGHT EXCEPTION! ðŸ’¥", {
    message: err.message,
    stack: err.stack,
  });
  process.exit(1);
});

// Graceful shutdown signals
process.on("SIGTERM", () => gracefulShutdown("SIGTERM"));
process.on("SIGINT", () => gracefulShutdown("SIGINT"));

export default server;


================================================================================
FILE: api-proxy-server/src\config\cors.ts
================================================================================

import { CorsOptions } from "cors";
import { env } from "./env.js";

export const corsOptions: CorsOptions = {
  origin: (origin, callback) => {
    const allowedOrigins = [env.FRONTEND_URL];

    // Allow requests with no origin (mobile apps, Postman, etc.)
    if (!origin || allowedOrigins.includes(origin)) {
      callback(null, true);
    } else {
      callback(new Error("Not allowed by CORS"));
    }
  },
  credentials: true,
  methods: ["GET", "POST", "PUT", "PATCH", "DELETE", "OPTIONS"],
  allowedHeaders: ["Content-Type", "Authorization", "X-Request-ID"],
  exposedHeaders: ["X-Request-ID", "Set-Cookie"],
  maxAge: 86400, // 24 hours
};


================================================================================
FILE: api-proxy-server/src\config\env.ts
================================================================================

import { z } from "zod";
import dotenv from "dotenv";

dotenv.config();

const envSchema = z.object({
  NODE_ENV: z
    .enum(["development", "production", "test"])
    .default("development"),
  PORT: z.coerce.number().default(4000),
  AUTH_SERVICE_URL: z.string().url(),
  INVENTORY_SERVICE_URL: z.string().url(),
  FRONTEND_URL: z.string().url().default("http://localhost:3000"),
  JWT_ISSUER: z.string().default("studio-s-auth"),
  JWT_AUDIENCE: z.string().default("studio-s-clients"),
  RATE_LIMIT_MAX_REQUESTS: z.coerce.number().default(100),
  RATE_LIMIT_WINDOW_MS: z.coerce.number().default(900000),
  JWKS_URL: z
    .string()
    .url()
    .default("http://localhost:5002/.well-known/jwks.json"),
});

export type Env = z.infer<typeof envSchema>;

let env: Env;

try {
  env = envSchema.parse(process.env);
} catch (error) {
  if (error instanceof z.ZodError) {
    console.error("âŒ Invalid environment variables:");
    error.issues.forEach((err) => {
      console.error(`  - ${err.path.join(".")}: ${err.message}`);
    });
  }
  process.exit(1);
}

export { env };


================================================================================
FILE: api-proxy-server/src\config\jwt.ts
================================================================================

import jwksRsa from 'jwks-rsa';
import { expressjwt } from 'express-jwt';
import { env } from './env.js';

export const checkJwt = expressjwt({
  algorithms: ['RS256'],
  issuer: env.JWT_ISSUER,
  audience: env.JWT_AUDIENCE,
  credentialsRequired: true,
  requestProperty: 'auth',
  secret: jwksRsa.expressJwtSecret({
    jwksUri: `${env.AUTH_SERVICE_URL}/.well-known/jwks.json`,
    cache: true,
    rateLimit: true,
    jwksRequestsPerMinute: 10,
  }),
});

================================================================================
FILE: api-proxy-server/src\controllers\errorController.ts
================================================================================

import { Request, Response, NextFunction } from "express";
import AppError from "../utils/appError.js";

const sendErrorDev = (err: AppError, res: Response) => {
  res.status(err.statusCode).json({
    status: err.status,
    error: err,
    message: err.message,
    stack: err.stack,
  });
};

const sendErrorProd = (err: AppError, res: Response) => {
  if (err.isOperational) {
    res.status(err.statusCode).json({
      status: err.status,
      message: err.message,
    });
  } else {
    console.error("ERROR ðŸ’¥", err);
    res.status(500).json({
      status: "error",
      message: "Something went very wrong!",
    });
  }
};

export default (
  err: AppError,
  req: Request,
  res: Response,
  next: NextFunction
) => {
  err.statusCode = err.statusCode || 500;
  err.status = err.status || "error";

  if (process.env.NODE_ENV === "development") {
    sendErrorDev(err, res);
  } else if (process.env.NODE_ENV === "production") {
    sendErrorProd(err, res);
  }
};


================================================================================
FILE: api-proxy-server/src\middleware\authMiddleware.ts
================================================================================

import { Request, Response, NextFunction } from "express";
import { jwtVerify, createRemoteJWKSet } from "jose";
import AppError from "../utils/appError.js";
import catchAsync from "../utils/catchAsync.js";
import { env } from "../config/env.js";

interface JwtPayload {
  sub: string;
  email: string;
  role: string;
  iat: number;
  exp: number;
  iss: string;
  aud: string;
}

export interface AuthRequest extends Request {
  user?: {
    id: string;
    email: string;
    role: string;
  };
}

// Create JWKS fetcher for verifying RSA signatures
const JWKS = createRemoteJWKSet(new URL(env.JWKS_URL));

export const protect = catchAsync(
  async (req: AuthRequest, res: Response, next: NextFunction) => {
    console.log("\nðŸ”’ PROTECT MIDDLEWARE");

    // 1) Get token from header or cookie
    let token: string | undefined;

    if (
      req.headers.authorization &&
      req.headers.authorization.startsWith("Bearer")
    ) {
      token = req.headers.authorization.split(" ")[1];
      console.log("âœ… Token from Authorization header");
    } else if (req.cookies.jwt) {
      token = req.cookies.jwt;
      console.log("âœ… Token from jwt cookie");
    }

    if (!token) {
      console.log("âŒ No token found");
      return next(
        new AppError("You are not logged in! Please log in to get access.", 401)
      );
    }

    // 2) Verify token using RSA public key from JWKS
    let decoded: JwtPayload;
    try {
      console.log("ðŸ” Verifying token with JWKS...");
      const { payload } = await jwtVerify(token, JWKS, {
        issuer: env.JWT_ISSUER,
        audience: env.JWT_AUDIENCE,
      });

      decoded = payload as unknown as JwtPayload;
      console.log("âœ… Token verified successfully");
      console.log("User:", decoded.sub, decoded.email, decoded.role);
    } catch (err: any) {
      console.log("âŒ Token verification failed:", err.message);
      if (err.code === "ERR_JWT_EXPIRED") {
        return next(
          new AppError("Your token has expired! Please log in again.", 401)
        );
      }
      return next(new AppError("Invalid token. Please log in again!", 401));
    }

    // 3) Attach user to request
    req.user = {
      id: decoded.sub,
      email: decoded.email,
      role: decoded.role,
    };

    console.log("âœ… User attached to request\n");
    next();
  }
);

export const restrictTo = (...roles: string[]) => {
  return (req: AuthRequest, res: Response, next: NextFunction) => {
    if (!req.user || !roles.includes(req.user.role)) {
      return next(
        new AppError("You do not have permission to perform this action", 403)
      );
    }
    next();
  };
};


================================================================================
FILE: api-proxy-server/src\middleware\cookieDebug.ts
================================================================================

import { Request, Response, NextFunction } from "express";

export const cookieDebugMiddleware = (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  console.log("\n=== COOKIE DEBUG ===");
  console.log("Path:", req.path);
  console.log("Method:", req.method);
  console.log("Cookie header:", req.headers.cookie);
  console.log("Parsed cookies:", req.cookies);
  console.log("===================\n");

  // Intercept res.setHeader to log Set-Cookie
  const originalSetHeader = res.setHeader.bind(res);
  res.setHeader = function (name: string, value: any) {
    if (name.toLowerCase() === "set-cookie") {
      console.log("\nðŸª SET-COOKIE BEING SET:");
      console.log(value);
      console.log("ðŸª END SET-COOKIE\n");
    }
    return originalSetHeader(name, value);
  };

  next();
};


================================================================================
FILE: api-proxy-server/src\middleware\errorHandler.ts
================================================================================

import { Request, Response, NextFunction } from "express";
import { UnauthorizedError } from "express-jwt";
import AppError from "../utils/appError.js";
import { logger } from "../utils/logger.js";
import { env } from "../config/env.js";

export const errorHandler = (
  err: Error | AppError | UnauthorizedError,
  req: Request,
  res: Response,
  next: NextFunction
) => {
  // Handle JWT errors
  if (err instanceof UnauthorizedError) {
    logger.warn("JWT Authentication failed", {
      requestId: req.requestId,
      code: err.code,
      message: err.message,
    });

    return res.status(401).json({
      status: "error",
      message: "Invalid or expired token",
      code: err.code,
      requestId: req.requestId,
    });
  }

  // Handle operational errors
  if (err instanceof AppError) {
    logger.error("Operational error", {
      message: err.message,
      statusCode: err.statusCode,
      requestId: req.requestId,
      stack: env.NODE_ENV === "development" ? err.stack : undefined,
    });

    return res.status(err.statusCode).json({
      status: err.status,
      message: err.message,
      requestId: req.requestId,
      ...(env.NODE_ENV === "development" && { stack: err.stack }),
    });
  }

  // Handle unknown errors
  logger.error("Unexpected error", {
    error: err.message,
    stack: err.stack,
    requestId: req.requestId,
  });

  res.status(500).json({
    status: "error",
    message:
      env.NODE_ENV === "production" ? "Something went wrong" : err.message,
    requestId: req.requestId,
    ...(env.NODE_ENV === "development" && { stack: err.stack }),
  });
};


================================================================================
FILE: api-proxy-server/src\middleware\queryParser.ts
================================================================================

import { Request, Response, NextFunction } from "express";
import { parse } from "querystring";

export const queryParser = (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  // Express 5 compatibility: ensure query is writable
  if (req.url.includes("?")) {
    const queryString = req.url.split("?")[1];
    try {
      // Parse manually if query is not set
      if (!req.query || Object.keys(req.query).length === 0) {
        const parsed = parse(queryString);
        Object.defineProperty(req, "query", {
          value: parsed,
          writable: true,
          enumerable: true,
          configurable: true,
        });
      }
    } catch (error) {
      console.error("Query parsing error:", error);
    }
  }
  next();
};


================================================================================
FILE: api-proxy-server/src\middleware\rateLimiter.ts
================================================================================

import rateLimit, { ipKeyGenerator } from "express-rate-limit";
import { env } from "../config/env.js";

// Normalize IP fallback (handles IPv4, ::ffff: mapped IPv4, and removes IPv6 scope ids)
function normalizeIp(req: any): string {
  const xff = req.headers["x-forwarded-for"];
  let ip = "";
  if (xff) {
    ip = Array.isArray(xff) ? xff[0] : String(xff).split(",")[0].trim();
  } else if (req.connection?.remoteAddress) {
    ip = req.connection.remoteAddress;
  } else if (req.socket?.remoteAddress) {
    ip = req.socket.remoteAddress;
  } else if (req.ip) {
    ip = req.ip;
  }
  if (ip && ip.startsWith("::ffff:")) ip = ip.replace("::ffff:", "");
  ip = ip.split("%")[0];
  return ip || "unknown";
}

// A keyGenerator wrapper that uses library helper when available (to satisfy express-rate-limit validation),
// otherwise falls back to normalizeIp.
function keyGenerator(req: any) {
  try {
    // ipKeyGenerator is present in recent versions; calling it satisfies the express-rate-limit checks
    if (typeof ipKeyGenerator === "function") {
      // ipKeyGenerator expects the raw request object
      return ipKeyGenerator(req);
    }
  } catch (err) {
    // ignore and fallback
  }
  return normalizeIp(req);
}

export const apiLimiter = rateLimit({
  windowMs: env.RATE_LIMIT_WINDOW_MS,
  max: env.RATE_LIMIT_MAX_REQUESTS,
  message: "Too many requests from this IP, please try again later.",
  standardHeaders: true,
  legacyHeaders: false,
  keyGenerator,
});

export const authLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 5, // 5 requests per window for login attempts
  message: "Too many login attempts, please try again later.",
  standardHeaders: true,
  legacyHeaders: false,
  keyGenerator,
  // skipSuccessfulRequests: true,
});


================================================================================
FILE: api-proxy-server/src\middleware\requestId.ts
================================================================================

import { Request, Response, NextFunction } from "express";
import crypto from "crypto";

export const requestId = (req: Request, res: Response, next: NextFunction) => {
  req.requestId =
    (req.headers["x-request-id"] as string) ||
    crypto.randomUUID?.() ||
    crypto.randomBytes(16).toString("hex");

  res.setHeader("X-Request-ID", req.requestId);
  next();
};


================================================================================
FILE: api-proxy-server/src\middleware\requestLogger.ts
================================================================================

import { Request, Response, NextFunction } from "express";
import { logger } from "../utils/logger.js";

export const requestLogger = (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  const start = Date.now();

  res.on("finish", () => {
    const duration = Date.now() - start;
    const logData = {
      requestId: req.requestId,
      method: req.method,
      path: req.path,
      statusCode: res.statusCode,
      duration: `${duration}ms`,
      userAgent: req.get("user-agent"),
      ip: req.ip,
    };

    if (res.statusCode >= 400) {
      logger.warn("HTTP Request", logData);
    } else {
      logger.info("HTTP Request", logData);
    }
  });

  next();
};


================================================================================
FILE: api-proxy-server/src\proxies\proxyFactory.ts
================================================================================

import { createProxyMiddleware, Options } from "http-proxy-middleware";
import { Request, Response } from "express";
import { logger } from "../utils/logger.js";
import { env } from "../config/env.js";

export interface ProxyConfig {
  target: string;
  pathRewrite?: Record<string, string>;
  timeout?: number;
}

export const createProxy = (config: ProxyConfig) => {
  const { target, pathRewrite, timeout = 30000 } = config;

  const options: Options = {
    target,
    changeOrigin: true,
    xfwd: true,
    proxyTimeout: timeout,
    timeout,
    pathRewrite,

    onProxyReq: (proxyReq, req: any, res: Response) => {
      // Forward client's cookie header to backend so backend sees jwt cookie
      if (req.headers.cookie) {
        proxyReq.setHeader("cookie", req.headers.cookie);
      }

      // If gateway already has authorization header, forward it
      const incomingAuth = req.get && req.get("authorization");
      if (incomingAuth && incomingAuth.startsWith("Bearer ")) {
        proxyReq.setHeader("authorization", incomingAuth);
      } else {
        // Try to extract jwt cookie and forward as Authorization header
        const cookieHeader = req.headers.cookie || "";
        const jwtMatch = cookieHeader.match(/(?:^|;\s*)jwt=([^;]+)/);
        if (jwtMatch && jwtMatch[1]) {
          proxyReq.setHeader("authorization", `Bearer ${jwtMatch[1]}`);
        }
      }

      // Forward any user context headers the gateway attached
      if (req.user) {
        if (req.user.id) proxyReq.setHeader("x-user-id", String(req.user.id));
        if (req.user.email)
          proxyReq.setHeader("x-user-email", String(req.user.email));
        if (req.user.role)
          proxyReq.setHeader("x-user-role", String(req.user.role));
      }

      // Restream parsed JSON body, if present
      if (req.body && Object.keys(req.body).length > 0) {
        const bodyData = JSON.stringify(req.body);
        proxyReq.setHeader("Content-Type", "application/json");
        proxyReq.setHeader("Content-Length", Buffer.byteLength(bodyData));
        proxyReq.write(bodyData);
        proxyReq.end();
      }

      logger.debug("Proxying request", {
        target,
        path: req.path,
        method: req.method,
        requestId: req.requestId,
      });
    },

    onProxyRes: (proxyRes, req: any, res: Response) => {
      // Handle Set-Cookie carefully â€” preserve multiple cookies
      const setCookie = proxyRes.headers["set-cookie"];
      if (setCookie) {
        // Optionally remove Secure when running plain http in development.
        // In production (env.NODE_ENV === 'production') keep Secure flag.
        const rewritten = setCookie.map((c: string) =>
          env.NODE_ENV === "development" ? c.replace(/; ?secure/gi, "") : c
        );
        res.setHeader("set-cookie", rewritten);
      }

      // Forward other safe headers (avoid hop-by-hop headers)
      const hopByHop = new Set([
        "connection",
        "keep-alive",
        "proxy-authenticate",
        "proxy-authorization",
        "te",
        "trailers",
        "transfer-encoding",
        "upgrade",
      ]);

      Object.keys(proxyRes.headers).forEach((key) => {
        const lower = key.toLowerCase();
        if (lower === "set-cookie") return;
        if (hopByHop.has(lower)) return;
        const value = proxyRes.headers[key];
        if (value !== undefined) {
          res.setHeader(key, value);
        }
      });

      logger.debug("Proxy response received", {
        target,
        statusCode: proxyRes.statusCode,
        requestId: req.requestId,
      });
    },

    onError: (err, req: any, res: Response) => {
      logger.error("Proxy error", {
        target,
        error: err?.message,
        requestId: req.requestId,
        path: req.path,
      });

      if (!res.headersSent) {
        res.status(503).json({
          status: "error",
          message: "Upstream service unavailable",
          service: target,
          requestId: req.requestId,
        });
      }
    },
  };

  return createProxyMiddleware(options);
};


================================================================================
FILE: api-proxy-server/src\routes\api.routes.ts
================================================================================

import { Router } from "express";
import { createProxy } from "../proxies/proxyFactory.js";
import { env } from "../config/env.js";

const router = Router();

// User management (from auth service)
router.use(
  "/users",
  createProxy({
    target: env.AUTH_SERVICE_URL,
    // Won't match because route is already stripped Router already consumed /api/v1
    pathRewrite: { "^/api/v1/users": "/api/v1/users" },
    // Path should stay the same - pathRewrite: {} - /api/v1/products â†’ /api/v1/products
  })
);

// Inventory service routes
const inventoryRoutes = [
  "products",
  "categories",
  "suppliers",
  "locations",
  "treatments",
]; // Will need to add all backend routes here

inventoryRoutes.forEach((route) => {
  router.use(
    `/${route}`,
    createProxy({
      target: env.INVENTORY_SERVICE_URL,
      pathRewrite: { [`^/${route}`]: `/api/v1/${route}` },
    })
  );
});

export default router;


================================================================================
FILE: api-proxy-server/src\routes\auth.routes.ts
================================================================================

import { Router, Request, Response, NextFunction } from "express";
import { createProxy } from "../proxies/proxyFactory.js";
import { env } from "../config/env.js";
import { authLimiter } from "../middleware/rateLimiter.js";
import { protect, AuthRequest } from "../middleware/authMiddleware.js";
import NodeCache from "node-cache";
import axios from "axios";

const router = Router();

const userCache = new NodeCache({ stdTTL: 300 }); // Cache user data for 5 minutes

// Apply strict rate limiting to auth routes
router.use(authLimiter);

router.use((req: Request, res: Response, next: NextFunction) => {
  // Ensure query string is parsed
  if (typeof req.query === "undefined") {
    (req as any).query = {};
  }
  next();
});

// PUBLIC routes - no authentication required
const publicAuthProxy = createProxy({
  target: env.AUTH_SERVICE_URL,
  pathRewrite: { "^/auth": "/auth" },
});

router.post("/signup", publicAuthProxy);
router.post("/login", publicAuthProxy);
router.post("/refresh", publicAuthProxy);
router.post("/logout", publicAuthProxy);
router.post("/forgot-password", publicAuthProxy);
router.patch("/reset-password/:token", publicAuthProxy);

// PROTECTED routes - authentication required
const protectedAuthProxy = createProxy({
  target: env.AUTH_SERVICE_URL,
  pathRewrite: { "^/auth": "/auth" },
});

router.get("/me", protect, (req, res, next) => {
  protectedAuthProxy(req, res, next);
});
router.patch("/update-password", protect, protectedAuthProxy);

export default router;


================================================================================
FILE: api-proxy-server/src\routes\health.ts
================================================================================

import { Router, Request, Response } from "express";
import axios from "axios";
import { env } from "../config/env.js";
import { logger } from "../utils/logger.js";
import catchAsync from "../utils/catchAsync.js";

const router = Router();

interface HealthStatus {
  status: "ok" | "degraded" | "down";
  timestamp: string;
  uptime: number;
  services: {
    gateway: "ok" | "down";
    auth: "ok" | "down" | "unknown";
    inventory: "ok" | "down" | "unknown";
  };
}

const checkService = async (url: string, timeout = 2000): Promise<boolean> => {
  try {
    const response = await axios.get(`${url}/health`, {
      timeout,
      validateStatus: (status) => status === 200,
    });
    return response.data.ok === true || response.status === 200;
  } catch (error) {
    return false;
  }
};

router.get(
  "/",
  catchAsync(async (req: Request, res: Response) => {
    const [authHealthy, inventoryHealthy] = await Promise.all([
      checkService(env.AUTH_SERVICE_URL),
      checkService(env.INVENTORY_SERVICE_URL),
    ]);

    const health: HealthStatus = {
      status: "ok",
      timestamp: new Date().toISOString(),
      uptime: process.uptime(),
      services: {
        gateway: "ok",
        auth: authHealthy ? "ok" : "down",
        inventory: inventoryHealthy ? "ok" : "down",
      },
    };

    // Determine overall status
    if (!authHealthy || !inventoryHealthy) {
      health.status = "degraded";
    }

    const statusCode = health.status === "ok" ? 200 : 503;

    logger.info("Health check performed", {
      status: health.status,
      services: health.services,
    });

    res.status(statusCode).json(health);
  })
);

// Liveness probe (always returns 200 if server is running)
router.get("/live", (req: Request, res: Response) => {
  res.status(200).json({ status: "alive" });
});

// Readiness probe (checks if ready to accept traffic)
router.get(
  "/ready",
  catchAsync(async (req: Request, res: Response) => {
    const authHealthy = await checkService(env.AUTH_SERVICE_URL, 1000);

    if (authHealthy) {
      res.status(200).json({ status: "ready" });
    } else {
      res.status(503).json({ status: "not ready" });
    }
  })
);

export default router;


================================================================================
FILE: api-proxy-server/src\routes\index.ts
================================================================================

import { Application } from "express";
import { checkJwt } from "../config/jwt.js";
import { apiLimiter } from "../middleware/rateLimiter.js";
import healthRoutes from "./health.js";
import authRoutes from "./auth.routes.js";
import apiRoutes from "./api.routes.js";

export const setupRoutes = (app: Application) => {
  // Health checks (no auth, no rate limit)
  app.use("/health", healthRoutes);

  // Auth routes (rate limited, no JWT)
  app.use("/auth", authRoutes);

  // Protected API routes (JWT required)
  app.use("/", apiLimiter, checkJwt, apiRoutes);
};


================================================================================
FILE: api-proxy-server/src\types\global.d.ts
================================================================================

import "express-serve-static-core";

declare module "express-serve-static-core" {
  interface Request {
    auth?: {
      sub?: string;
      email?: string;
      role?: string;
      firstName?: string;
      lastName?: string;
      [key: string]: any;
    };
    requestId?: string;
  }
}


================================================================================
FILE: api-proxy-server/src\utils\appError.ts
================================================================================

class AppError extends Error {
  statusCode: number;
  status: string;
  isOperational: boolean;
  static notFound: any;

  constructor(message: string, statusCode: number) {
    super(message);

    this.statusCode = statusCode;
    this.status = `${statusCode}`.startsWith("4") ? "fail" : "error";
    this.isOperational = true;

    Error.captureStackTrace(this, this.constructor);
  }
}

export default AppError;


================================================================================
FILE: api-proxy-server/src\utils\catchAsync.ts
================================================================================

import { Request, Response, NextFunction } from "express";

export default (fn: Function) => {
  return (req: Request, res: Response, next: NextFunction) => {
    Promise.resolve(fn(req, res, next)).catch(next);
  };
};


================================================================================
FILE: api-proxy-server/src\utils\logger.ts
================================================================================

import winston from 'winston';
import { env } from '../config/env.js';

const logFormat = winston.format.combine(
  winston.format.timestamp({ format: 'YYYY-MM-DD HH:mm:ss' }),
  winston.format.errors({ stack: true }),
  winston.format.splat(),
  winston.format.json()
);

const consoleFormat = winston.format.combine(
  winston.format.colorize(),
  winston.format.printf(({ timestamp, level, message, ...meta }) => {
    let msg = `${timestamp} [${level}]: ${message}`;
    if (Object.keys(meta).length > 0) {
      msg += ` ${JSON.stringify(meta)}`;
    }
    return msg;
  })
);

export const logger = winston.createLogger({
  level: env.NODE_ENV === 'production' ? 'info' : 'debug',
  format: logFormat,
  defaultMeta: { service: 'api-gateway' },
  transports: [
    new winston.transports.Console({
      format: consoleFormat,
    }),
  ],
});

// Add file transports in production
if (env.NODE_ENV === 'production') {
  logger.add(
    new winston.transports.File({
      filename: 'logs/error.log',
      level: 'error',
      maxsize: 5242880, // 5MB
      maxFiles: 5,
    })
  );
  logger.add(
    new winston.transports.File({
      filename: 'logs/combined.log',
      maxsize: 5242880,
      maxFiles: 5,
    })
  );
}
